"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[6282],{66262:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,e]of n)a[s]=e;return a}},26771:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>d,data:()=>r});var e=a(20641);const i=a.p+"assets/img/image-20200323155120778.b568193a.png",l=a.p+"assets/img/image-20200324123829937.6b9289a0.png",p=[(0,e.Fv)('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>在原来的时候，我们谈到一个类的实例化</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Person p = new Person()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在等号的左边，就是一个对象的引用，存储在栈中</p><p>而等号右边，就是实例化的对象，存储在堆中</p><p>其实这样的一个引用关系，就被称为强引用</p><h2 id="整体架构" tabindex="-1"><a class="header-anchor" href="#整体架构"><span>整体架构</span></a></h2><figure><img src="'+i+'" alt="image-20200323155120778" tabindex="0" loading="lazy"><figcaption>image-20200323155120778</figcaption></figure><h2 id="强引用" tabindex="-1"><a class="header-anchor" href="#强引用"><span>强引用</span></a></h2><p>当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，打死也不回收~！</p><p>强引用是我们最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，因此强引用是造成Java内存泄漏的主要原因之一。</p><p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用于或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p><p>强引用小例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 强引用</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-23-16:25</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class StrongReferenceDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        // 这样定义的默认就是强应用</span></span>\n<span class="line"><span>        Object obj1 = new Object();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 使用第二个引用，指向刚刚创建的Object对象</span></span>\n<span class="line"><span>        Object obj2 = obj1;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 置空</span></span>\n<span class="line"><span>        obj1 = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 垃圾回收</span></span>\n<span class="line"><span>        System.gc();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(obj1);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(obj2);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并没有将该对象进行垃圾回收</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>null</span></span>\n<span class="line"><span>java.lang.Object@14ae5a5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="软引用" tabindex="-1"><a class="header-anchor" href="#软引用"><span>软引用</span></a></h2><p>软引用是一种相对弱化了一些的引用，需要用Java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p><ul><li>当系统内存充足时，它不会被回收</li><li>当系统内存不足时，它会被回收</li></ul><p>软引用通常在对内存敏感的程序中，比如高速缓存就用到了软引用，内存够用 的时候就保留，不够用就回收</p><p>具体使用</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 软引用</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-23-16:39</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class SoftReferenceDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 内存够用的时候</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public static void softRefMemoryEnough() {</span></span>\n<span class="line"><span>        // 创建一个强应用</span></span>\n<span class="line"><span>        Object o1 = new Object();</span></span>\n<span class="line"><span>        // 创建一个软引用</span></span>\n<span class="line"><span>        SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1);</span></span>\n<span class="line"><span>        System.out.println(o1);</span></span>\n<span class="line"><span>        System.out.println(softReference.get());</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        o1 = null;</span></span>\n<span class="line"><span>        // 手动GC</span></span>\n<span class="line"><span>        System.gc();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(o1);</span></span>\n<span class="line"><span>        System.out.println(softReference.get());</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况</span></span>\n<span class="line"><span>     * -Xms5m -Xmx5m -XX:+PrintGCDetails</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public static void softRefMemoryNoEnough() {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(&quot;========================&quot;);</span></span>\n<span class="line"><span>        // 创建一个强应用</span></span>\n<span class="line"><span>        Object o1 = new Object();</span></span>\n<span class="line"><span>        // 创建一个软引用</span></span>\n<span class="line"><span>        SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1);</span></span>\n<span class="line"><span>        System.out.println(o1);</span></span>\n<span class="line"><span>        System.out.println(softReference.get());</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        o1 = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 模拟OOM自动GC</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 创建30M的大对象</span></span>\n<span class="line"><span>            byte[] bytes = new byte[30 * 1024 * 1024];</span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            System.out.println(o1);</span></span>\n<span class="line"><span>            System.out.println(softReference.get());</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        softRefMemoryEnough();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        softRefMemoryNoEnough();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候</p><p>我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值</p><p>然后我们把o1设置为null，执行手动GC后，我们发现softReference的值还存在，说明内存充足的时候，软引用的对象不会被回收</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>java.lang.Object@14ae5a5</span></span>\n<span class="line"><span>java.lang.Object@14ae5a5</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>[GC (System.gc()) [PSYoungGen: 1396K-&gt;504K(1536K)] 1504K-&gt;732K(5632K), 0.0007842 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span>[Full GC (System.gc()) [PSYoungGen: 504K-&gt;0K(1536K)] [ParOldGen: 228K-&gt;651K(4096K)] 732K-&gt;651K(5632K), [Metaspace: 3480K-&gt;3480K(1056768K)], 0.0058450 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>null</span></span>\n<span class="line"><span>java.lang.Object@14ae5a5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们看当内存不够的时候，我们使用了JVM启动参数配置，给初始化堆内存为5M</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-Xms5m -Xmx5m -XX:+PrintGCDetails</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>但是在创建对象的时候，我们创建了一个30M的大对象</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 创建30M的大对象</span></span>\n<span class="line"><span>byte[] bytes = new byte[30 * 1024 * 1024];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明，软引用在内存不足的时候，会自动回收</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>java.lang.Object@7f31245a</span></span>\n<span class="line"><span>java.lang.Object@7f31245a</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>[GC (Allocation Failure) [PSYoungGen: 31K-&gt;160K(1536K)] 682K-&gt;811K(5632K), 0.0003603 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span>[GC (Allocation Failure) [PSYoungGen: 160K-&gt;96K(1536K)] 811K-&gt;747K(5632K), 0.0006385 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span>[Full GC (Allocation Failure) [PSYoungGen: 96K-&gt;0K(1536K)] [ParOldGen: 651K-&gt;646K(4096K)] 747K-&gt;646K(5632K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0067976 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </span></span>\n<span class="line"><span>[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 646K-&gt;646K(5632K), 0.0004024 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span>[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 646K-&gt;627K(4096K)] 646K-&gt;627K(5632K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0065506 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>null</span></span>\n<span class="line"><span>null</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="弱引用" tabindex="-1"><a class="header-anchor" href="#弱引用"><span>弱引用</span></a></h2><p>不管内存是否够，只要有GC操作就会进行回收</p><p>弱引用需要用 <code>java.lang.ref.WeakReference</code> 类来实现，它比软引用生存期更短</p><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的空间。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 弱引用</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2023-03-05</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class WeakReferenceDemo {</span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        Object o1 = new Object();</span></span>\n<span class="line"><span>        WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(o1);</span></span>\n<span class="line"><span>        System.out.println(o1);</span></span>\n<span class="line"><span>        System.out.println(weakReference.get());</span></span>\n<span class="line"><span>        o1 = null;</span></span>\n<span class="line"><span>        System.gc();</span></span>\n<span class="line"><span>        System.out.println(o1);</span></span>\n<span class="line"><span>        System.out.println(weakReference.get());</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看结果，能够发现，我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>java.lang.Object@14ae5a5</span></span>\n<span class="line"><span>java.lang.Object@14ae5a5</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>[GC (System.gc()) [PSYoungGen: 5246K-&gt;808K(76288K)] 5246K-&gt;816K(251392K), 0.0008236 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span>[Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;675K(175104K)] 816K-&gt;675K(251392K), [Metaspace: 3494K-&gt;3494K(1056768K)], 0.0035953 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>null</span></span>\n<span class="line"><span>null</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="软引用和弱引用的使用场景" tabindex="-1"><a class="header-anchor" href="#软引用和弱引用的使用场景"><span>软引用和弱引用的使用场景</span></a></h2><p>场景：假如有一个应用需要读取大量的本地图片</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能</li><li>如果一次性全部加载到内存中，又可能造成内存溢出</li></ul><p>此时使用软引用可以解决这个问题</p><p>设计思路：使用HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占的空间，从而有效地避免了OOM的问题</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Map&lt;String, SoftReference&lt;String&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="weakhashmap是什么" tabindex="-1"><a class="header-anchor" href="#weakhashmap是什么"><span>WeakHashMap是什么？</span></a></h3><p>比如一些常常和底层打交道的，mybatis等，底层都应用到了WeakHashMap</p><p>WeakHashMap和HashMap类似，只不过它的Key是使用了弱引用的，也就是说，当执行GC的时候，HashMap中的key会进行回收，下面我们使用例子来测试一下</p><p>我们使用了两个方法，一个是普通的HashMap方法</p><p>我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    private static void myHashMap() {</span></span>\n<span class="line"><span>        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span></span>\n<span class="line"><span>        Integer key = 1;</span></span>\n<span class="line"><span>        String value = &quot;HashMap&quot;;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        map.put(key, value);</span></span>\n<span class="line"><span>        System.out.println(map);</span></span>\n<span class="line"><span>        // 没卵用</span></span>\n<span class="line"><span>        key = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.gc();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(map);</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二个是使用了WeakHashMap，完整代码如下</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * WeakHashMap</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2023-03-05</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class WeakHashMapDemo {</span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        myHashMap();</span></span>\n<span class="line"><span>        System.out.println(&quot;==========&quot;);</span></span>\n<span class="line"><span>        myWeakHashMap();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private static void myHashMap() {</span></span>\n<span class="line"><span>        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span></span>\n<span class="line"><span>        Integer key = 1;</span></span>\n<span class="line"><span>        String value = &quot;HashMap&quot;;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        map.put(key, value);</span></span>\n<span class="line"><span>        System.out.println(map);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        key = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.gc();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(map);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private static void myWeakHashMap() {</span></span>\n<span class="line"><span>        Map&lt;Integer, String&gt; map = new WeakHashMap&lt;&gt;();</span></span>\n<span class="line"><span>        Integer key = 1;</span></span>\n<span class="line"><span>        String value = &quot;WeakHashMap&quot;;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        map.put(key, value);</span></span>\n<span class="line"><span>        System.out.println(map);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        key = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.gc();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(map);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后输出结果为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{1=HashMap}</span></span>\n<span class="line"><span>{1=HashMap}</span></span>\n<span class="line"><span>==========</span></span>\n<span class="line"><span>{1=WeakHashMap}</span></span>\n<span class="line"><span>{}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p><p>但是WeakHashMap，在进行GC操作后，弱引用的就会被回收</p><h2 id="虚引用" tabindex="-1"><a class="header-anchor" href="#虚引用"><span>虚引用</span></a></h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><p>虚引用又称为幽灵引用，需要<code>java.lang.ref.PhantomReference</code> 类来实现</p><p>顾名思义，就是<code>形同虚设</code>，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p><p><code>如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收</code>，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列ReferenceQueue联合使用。</p><p>虚引用的主要作用和跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</p><p>PhantomReference的get方法总是返回null，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</p><p>这个就相当于Spring AOP里面的后置通知</p><h3 id="场景" tabindex="-1"><a class="header-anchor" href="#场景"><span>场景</span></a></h3><p>一般用于在回收时候做通知相关操作</p><h2 id="引用队列-referencequeue" tabindex="-1"><a class="header-anchor" href="#引用队列-referencequeue"><span>引用队列 ReferenceQueue</span></a></h2><p>软引用，弱引用，虚引用在回收之前，需要在引用队列保存一下</p><p>我们在初始化的弱引用或者虚引用的时候，可以传入一个引用队列</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Object o1 = new Object();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 创建引用队列</span></span>\n<span class="line"><span>ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 创建一个弱引用</span></span>\n<span class="line"><span>WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(o1, referenceQueue);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么在进行GC回收的时候，弱引用和虚引用的对象都会被回收，但是在回收之前，它会被送至引用队列中</p><p>完整代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 虚引用</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2023-03-05</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class PhantomReferenceDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        Object o1 = new Object();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 创建引用队列</span></span>\n<span class="line"><span>        ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 创建一个弱引用</span></span>\n<span class="line"><span>        WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(o1, referenceQueue);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 创建一个弱引用</span></span>\n<span class="line"><span>//        PhantomReference&lt;Object&gt; weakReference = new PhantomReference&lt;&gt;(o1, referenceQueue);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(o1);</span></span>\n<span class="line"><span>        System.out.println(weakReference.get());</span></span>\n<span class="line"><span>        // 取队列中的内容</span></span>\n<span class="line"><span>        System.out.println(referenceQueue.poll());</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        o1 = null;</span></span>\n<span class="line"><span>        System.gc();</span></span>\n<span class="line"><span>        System.out.println(&quot;执行GC操作&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            TimeUnit.SECONDS.sleep(2);</span></span>\n<span class="line"><span>        } catch (InterruptedException e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(o1);</span></span>\n<span class="line"><span>        System.out.println(weakReference.get());</span></span>\n<span class="line"><span>        // 取队列中的内容</span></span>\n<span class="line"><span>        System.out.println(referenceQueue.poll());</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>java.lang.Object@14ae5a5</span></span>\n<span class="line"><span>java.lang.Object@14ae5a5</span></span>\n<span class="line"><span>null</span></span>\n<span class="line"><span>执行GC操作</span></span>\n<span class="line"><span>null</span></span>\n<span class="line"><span>null</span></span>\n<span class="line"><span>java.lang.ref.WeakReference@7f3124</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这里我们能看到，在进行垃圾回收后，我们弱引用对象，也被设置成null，但是在队列中还能够导出该引用的实例，这就说明在回收之前，该弱引用的实例被放置引用队列中了，我们可以通过引用队列进行一些后置操作</p><h2 id="gcroots和四大引用小总结" tabindex="-1"><a class="header-anchor" href="#gcroots和四大引用小总结"><span>GCRoots和四大引用小总结</span></a></h2><ul><li><p>红色部分在垃圾回收之外，也就是强引用的</p></li><li><p>蓝色部分：属于软引用，在内存不够的时候，才回收</p></li><li><p>虚引用和弱引用：每次垃圾回收的时候，都会被干掉，但是<code>它在干掉之前还会存在引用队列中</code>，我们可以通过引用队列进行一些通知机制</p></li></ul><figure><img src="'+l+'" alt="image-20200324123829937" tabindex="0" loading="lazy"><figcaption>image-20200324123829937</figcaption></figure>',81)],c={},d=(0,a(66262).A)(c,[["render",function(s,n){return(0,e.uX)(),(0,e.CE)("div",null,p)}]]),r=JSON.parse('{"path":"/study-notes/shangguigu-second/JVM/four.html","title":"Java中的引用","lang":"zh-CN","frontmatter":{"title":"Java中的引用","date":"2023-03-11T00:00:00.000Z","tags":["Java中的引用"],"category":["JUC"],"description":"前言 在原来的时候，我们谈到一个类的实例化 在等号的左边，就是一个对象的引用，存储在栈中 而等号右边，就是实例化的对象，存储在堆中 其实这样的一个引用关系，就被称为强引用 整体架构 image-20200323155120778image-20200323155120778 强引用 当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，就算是出现了O...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-second/JVM/four.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"Java中的引用"}],["meta",{"property":"og:description","content":"前言 在原来的时候，我们谈到一个类的实例化 在等号的左边，就是一个对象的引用，存储在栈中 而等号右边，就是实例化的对象，存储在堆中 其实这样的一个引用关系，就被称为强引用 整体架构 image-20200323155120778image-20200323155120778 强引用 当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，就算是出现了O..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"Java中的引用"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java中的引用\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"整体架构","slug":"整体架构","link":"#整体架构","children":[]},{"level":2,"title":"强引用","slug":"强引用","link":"#强引用","children":[]},{"level":2,"title":"软引用","slug":"软引用","link":"#软引用","children":[]},{"level":2,"title":"弱引用","slug":"弱引用","link":"#弱引用","children":[]},{"level":2,"title":"软引用和弱引用的使用场景","slug":"软引用和弱引用的使用场景","link":"#软引用和弱引用的使用场景","children":[{"level":3,"title":"WeakHashMap是什么？","slug":"weakhashmap是什么","link":"#weakhashmap是什么","children":[]}]},{"level":2,"title":"虚引用","slug":"虚引用","link":"#虚引用","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"场景","slug":"场景","link":"#场景","children":[]}]},{"level":2,"title":"引用队列 ReferenceQueue","slug":"引用队列-referencequeue","link":"#引用队列-referencequeue","children":[]},{"level":2,"title":"GCRoots和四大引用小总结","slug":"gcroots和四大引用小总结","link":"#gcroots和四大引用小总结","children":[]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":9.46,"words":2837},"filePathRelative":"study-notes/shangguigu-second/JVM/four.md","localizedDate":"2023年3月11日","excerpt":"<h2>前言</h2>\\n<p>在原来的时候，我们谈到一个类的实例化</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>Person p = new Person()</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);