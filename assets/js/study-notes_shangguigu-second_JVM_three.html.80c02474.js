"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[6704],{66262:(i,e)=>{e.A=(i,e)=>{const s=i.__vccOpts||i;for(const[i,a]of e)s[i]=a;return s}},45111:(i,e,s)=>{s.r(e),s.d(e,{comp:()=>g,data:()=>v});var a=s(20641);const n=s.p+"assets/img/image-20200319122922264.a5298813.png",l=s.p+"assets/img/image-20200320212256284.829d1a58.png",t=s.p+"assets/img/image-20200322163252777.3aca736a.png",r=s.p+"assets/img/image-20200322185639902.c6290d06.png",d=s.p+"assets/img/image-20200323124000865.fe1be96f.png",p=s.p+"assets/img/image-20200323125839653.63efeadc.png",c=s.p+"assets/img/image-20200323130442088.fed6c43b.png",h=s.p+"assets/img/image-20200323150946414.d397224a.png",o=[(0,a.Fv)('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>你说你做过JVM调优和参数配置，请问如何盘点查看JVM系统默认值</p><p>使用jps和jinfo进行查看</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-Xms：初始堆空间</span></span>\n<span class="line"><span>-Xmx：堆最大值</span></span>\n<span class="line"><span>-Xss：栈空间</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>-Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收</p><h2 id="jvm参数类型" tabindex="-1"><a class="header-anchor" href="#jvm参数类型"><span>JVM参数类型</span></a></h2><ul><li>标配参数（从JDK1.0 - Java12都在，很稳定） <ul><li>-version</li><li>-help</li><li>java -showversion</li></ul></li><li>X参数（了解） <ul><li>-Xint：解释执行</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式</li></ul></li><li>XX参数（重点） <ul><li>Boolean类型 <ul><li>公式：-XX:+ 或者-某个属性， <code>+ 表示开启，-表示关闭</code></li><li>Case：-XX:-PrintGCDetails：表示关闭了GC详情输出</li></ul></li><li>key-value类型 <ul><li>公式：-XX:属性key=属性value</li><li>不满意初始值，可以通过下列命令调整</li><li>case：例如：-XX:MetaspaceSize=21807104：查看Java元空间的值</li></ul></li></ul></li></ul><h2 id="查看运行的java程序-jvm参数是否开启-具体值为多少" tabindex="-1"><a class="header-anchor" href="#查看运行的java程序-jvm参数是否开启-具体值为多少"><span>查看运行的Java程序，JVM参数是否开启，具体值为多少？</span></a></h2><p>首先我们运行一个HelloGC的java程序</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-19-12:14</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class HelloGC {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) throws InterruptedException {</span></span>\n<span class="line"><span>        System.out.println(&quot;hello GC&quot;);</span></span>\n<span class="line"><span>        Thread.sleep(Integer.MAX_VALUE);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后使用下列命令查看它的默认参数</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jps：查看java的后台进程</span></span>\n<span class="line"><span>jinfo：查看正在运行的java程序</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>具体使用：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jps -l得到进程号</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>8116 com.moxi.interview.study.GC.HelloGC</span></span>\n<span class="line"><span>15200 sun.tools.jps.Jps</span></span>\n<span class="line"><span>15296 org.jetbrains.idea.maven.server.RemoteMavenServer36</span></span>\n<span class="line"><span>4528</span></span>\n<span class="line"><span>12216 org.jetbrains.jps.cmdline.Launcher</span></span>\n<span class="line"><span>9772 org.jetbrains.kotlin.daemon.KotlinCompileDaemon</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看到HelloGC的进程号为：8116</p><p>我们使用jinfo -flag 然后查看是否开启PrintGCDetails这个参数</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jinfo -flag PrintGCDetails 12608</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>得到的内容为</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-XX:-PrintGCDetails</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面提到了，-号表示关闭，即没有开启PrintGCDetails这个参数</p><p>下面我们需要在启动HelloGC的时候，增加 PrintGCDetails这个参数，需要在运行程序的时候配置JVM参数</p><figure><img src="'+n+'" alt="image-20200319122922264" tabindex="0" loading="lazy"><figcaption>image-20200319122922264</figcaption></figure><p>然后在VM Options中加入下面的代码，现在+号表示开启</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-XX:+PrintGCDetails</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后在使用jinfo查看我们的配置</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jps -l</span></span>\n<span class="line"><span>jinfo -flag PrintGCDetails 13540</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>得到的结果为</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-XX:+PrintGCDetails</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们看到原来的-号变成了+号，说明我们通过 VM Options配置的JVM参数已经生效了</p><p>再比如，查看MetaspaceSize：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">jps</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -l</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">jinfo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -flag</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> MetaspaceSize</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 13540</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>得到默认值：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-XX:MetaspaceSize</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">=21807104</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用下列命令，会把jvm的全部默认参数输出</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jinfo -flags ***(id)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="题外话-坑题" tabindex="-1"><a class="header-anchor" href="#题外话-坑题"><span>题外话（坑题）</span></a></h2><p>两个经典参数：-Xms 和 -Xmx，这两个参数 如何解释</p><p>这两个参数，还是属于XX参数，因为取了别名</p><ul><li>-Xms 等价于 -XX:InitialHeapSize ：初始化堆内存（默认只会用最大物理内存的64分1）</li><li>-Xmx 等价于 -XX:MaxHeapSize ：最大堆内存（默认只会用最大物理内存的4分1）</li></ul><h2 id="查看jvm默认参数" tabindex="-1"><a class="header-anchor" href="#查看jvm默认参数"><span>查看JVM默认参数</span></a></h2><ul><li><p>-XX:+PrintFlagsInitial</p><ul><li>主要是查看初始默认值</li><li>公式 <ul><li>java -XX:+PrintFlagsInitial -version</li><li><code>java -XX:+PrintFlagsInitial</code><strong>（重要参数）</strong></li></ul></li></ul><figure><img src="'+l+'" alt="image-20200320212256284" tabindex="0" loading="lazy"><figcaption>image-20200320212256284</figcaption></figure></li><li><p>-XX:+PrintFlagsFinal：表示修改以后，最终的值</p><pre><code>   会将JVM的各个结果都进行打印\n\n  如果有  := 表示修改过的， = 表示没有修改过的\n</code></pre></li></ul><h2 id="工作中常用的jvm基本配置参数" tabindex="-1"><a class="header-anchor" href="#工作中常用的jvm基本配置参数"><span>工作中常用的JVM基本配置参数</span></a></h2><figure><img src="'+t+'" alt="image-20200322163252777" tabindex="0" loading="lazy"><figcaption>image-20200322163252777</figcaption></figure><h3 id="查看堆内存" tabindex="-1"><a class="header-anchor" href="#查看堆内存"><span>查看堆内存</span></a></h3><p>查看JVM的初始化堆内存 -Xms 和最大堆内存 Xmx</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2023-03-05</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class HelloGC {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) throws InterruptedException {</span></span>\n<span class="line"><span>        // 返回Java虚拟机中内存的总量</span></span>\n<span class="line"><span>        long totalMemory = Runtime.getRuntime().totalMemory();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 返回Java虚拟机中试图使用的最大内存量</span></span>\n<span class="line"><span>        long maxMemory = Runtime.getRuntime().maxMemory();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(&quot;TOTAL_MEMORY(-Xms) = &quot; + totalMemory + &quot;(字节)、&quot; + (totalMemory / (double)1024 / 1024) + &quot;MB&quot;);</span></span>\n<span class="line"><span>        System.out.println(&quot;MAX_MEMORY(-Xmx) = &quot; + maxMemory + &quot;(字节)、&quot; + (maxMemory / (double)1024 / 1024) + &quot;MB&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>TOTAL_MEMORY(-Xms) = 257425408(字节)、245.5MB</span></span>\n<span class="line"><span>MAX_MEMORY(-Xmx) = 3790077952(字节)、3614.5MB</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>-Xms 初始堆内存为：物理内存的1/64 -Xmx 最大堆内存为：系统物理内存的 1/4</p><h3 id="打印jvm默认参数" tabindex="-1"><a class="header-anchor" href="#打印jvm默认参数"><span>打印JVM默认参数</span></a></h3><p>使用 <code>-XX:+PrintCommandLineFlags</code> 打印出JVM的默认的简单初始化参数</p><p>比如我的机器输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-XX:InitialHeapSize=266376000 -XX:MaxHeapSize=4262016000 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以查看垃圾回收器。 <code>-XX:+UseParallelGC </code></p><h3 id="生活常用调优参数" tabindex="-1"><a class="header-anchor" href="#生活常用调优参数"><span>生活常用调优参数</span></a></h3><ul><li>-Xms：初始化堆内存，默认为物理内存的1/64，等价于 -XX:initialHeapSize</li><li>-Xmx：最大堆内存，默认为物理内存的1/4，等价于-XX:MaxHeapSize</li><li>-Xss：设计单个线程栈的大小，一般默认为512K~1024K，等价于 -XX:ThreadStackSize <ul><li>使用jinfo -flag ThreadStackSize 会发现 -XX:ThreadStackSize = 0</li><li><strong>这个值的大小是取决于平台的</strong></li><li>Linux/x64: 1024KB</li><li>OS X: 1024KB</li><li>Oracle Solaris：1024KB</li><li>Windows：取决于虚拟内存的大小</li></ul></li><li>-Xmn：设置年轻代大小</li><li>-XX:MetaspaceSize：设置元空间大小 <ul><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>-Xms10m -Xmx10m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal</li><li>但是默认的元空间大小：只有20多M</li><li>为了防止在频繁的实例化对象的时候，让元空间出现OOM，因此可以把元空间设置的大一些</li></ul></li><li>-XX:PrintGCDetails：输出详细GC收集日志信息 <ul><li>GC</li><li>Full GC</li></ul></li></ul><p>GC日志收集流程图</p><figure><img src="'+r+'" alt="image-20200322185639902" tabindex="0" loading="lazy"><figcaption>image-20200322185639902</figcaption></figure><p>我们使用一段代码，制造出垃圾回收的过程</p><p>首先我们设置一下程序的启动配置: 设置初始堆内存为10M，最大堆内存为10M</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-Xms10m -Xmx10m -XX:+PrintGCDetails</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后用下列代码，创建一个 非常大空间的byte类型数组</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>byte [] byteArray = new byte[50 * 1024 * 1024];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>运行后，发现会出现下列错误，这就是OOM：java内存溢出，也就是堆空间不足</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.GC.HelloGC.main(HelloGC.java:22)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>同时还打印出了GC垃圾回收时候的详情</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[GC (Allocation Failure) [PSYoungGen: 1972K-&gt;504K(2560K)] 1972K-&gt;740K(9728K), 0.0156109 secs] [Times: user=0.00 sys=0.00, real=0.03 secs] </span></span>\n<span class="line"><span>[GC (Allocation Failure) [PSYoungGen: 504K-&gt;480K(2560K)] 740K-&gt;772K(9728K), 0.0007815 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span>[Full GC (Allocation Failure) [PSYoungGen: 480K-&gt;0K(2560K)] [ParOldGen: 292K-&gt;648K(7168K)] 772K-&gt;648K(9728K), [Metaspace: 3467K-&gt;3467K(1056768K)], 0.0080505 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span></span>\n<span class="line"><span>[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 648K-&gt;648K(9728K), 0.0003035 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span>[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 648K-&gt;630K(7168K)] 648K-&gt;630K(9728K), [Metaspace: 3467K-&gt;3467K(1056768K)], 0.0058502 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span></span>\n<span class="line"><span>Heap</span></span>\n<span class="line"><span> PSYoungGen      total 2560K, used 80K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span></span>\n<span class="line"><span>  eden space 2048K, 3% used [0x00000000ffd00000,0x00000000ffd143d8,0x00000000fff00000)</span></span>\n<span class="line"><span>  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span></span>\n<span class="line"><span>  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span></span>\n<span class="line"><span> ParOldGen       total 7168K, used 630K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span></span>\n<span class="line"><span>  object space 7168K, 8% used [0x00000000ff600000,0x00000000ff69dbd0,0x00000000ffd00000)</span></span>\n<span class="line"><span> Metaspace       used 3510K, capacity 4500K, committed 4864K, reserved 1056768K</span></span>\n<span class="line"><span>  class space    used 389K, capacity 392K, committed 512K, reserved 1048576K</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问题发生的原因：</p><p>因为们通过 -Xms10m 和 -Xmx10m 只给Java堆栈设置了10M的空间，但是创建了50M的对象，因此就会出现空间不足，而导致出错</p><p>同时在垃圾收集的时候，我们看到有两个对象：GC 和 Full GC</p><h4 id="gc垃圾收集" tabindex="-1"><a class="header-anchor" href="#gc垃圾收集"><span>GC垃圾收集</span></a></h4><p>GC在新生区</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[GC (Allocation Failure) [PSYoungGen: 1972K-&gt;504K(2560K)] 1972K-&gt;740K(9728K), 0.0156109 secs] [Times: user=0.00 sys=0.00, real=0.03 secs]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>GC (Allocation Failure)：表示分配失败，那么就需要触发年轻代空间中的内容被回收</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[PSYoungGen: 1972K-&gt;504K(2560K)] 1972K-&gt;740K(9728K), 0.0156109 secs]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>参数对应的图为：</p><figure><img src="'+d+'" alt="image-20200323124000865" tabindex="0" loading="lazy"><figcaption>image-20200323124000865</figcaption></figure><h4 id="full-gc垃圾回收" tabindex="-1"><a class="header-anchor" href="#full-gc垃圾回收"><span>Full GC垃圾回收</span></a></h4><p>Full GC大部分发生在养老区</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 648K-&gt;630K(7168K)] 648K-&gt;630K(9728K), [Metaspace: 3467K-&gt;3467K(1056768K)], 0.0058502 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+p+'" alt="image-20200323125839653" tabindex="0" loading="lazy"><figcaption>image-20200323125839653</figcaption></figure><p>规律：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[名称： GC前内存占用 -&gt; GC后内存占用 (该区内存总大小)]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当我们出现了老年代都扛不住的时候，就会出现OOM异常</p><h3 id="xx-survivorratio" tabindex="-1"><a class="header-anchor" href="#xx-survivorratio"><span>-XX:SurvivorRatio</span></a></h3><p>调节新生代中 eden 和 S0、S1的空间比例，默认为 -XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</p><p>加入设置成 -XX:SurvivorRatio=4，则为 Eden:S0:S1 = 4:1:1</p><p>SurvivorRatio值就是设置eden区的比例占多少，S0和S1相同</p><p>Java堆从GC的角度还可以细分为：新生代（Eden区，From Survivor区合To Survivor区）和老年代</p><figure><img src="'+c+'" alt="image-20200323130442088" tabindex="0" loading="lazy"><figcaption>image-20200323130442088</figcaption></figure><ul><li>eden、SurvivorFrom复制到SurvivorTo，年龄 + 1</li></ul><p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom去，当Eden区再次触发GC的时候会扫描Eden区合From区域，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域（如果对象的年龄已经到达老年的标准，则赋值到老年代区），通知把这些对象的年龄 + 1</p><ul><li>清空eden、SurvivorFrom</li></ul><p>然后，清空eden，SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</p><ul><li>SurvivorTo和SurvivorFrom互换</li></ul><p>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p><figure><img src="'+h+'" alt="image-20200323150946414" tabindex="0" loading="lazy"><figcaption>image-20200323150946414</figcaption></figure><h3 id="xx-newratio-了解" tabindex="-1"><a class="header-anchor" href="#xx-newratio-了解"><span>-XX:NewRatio（了解）</span></a></h3><p>配置年轻代new 和老年代old 在堆结构的占比</p><p>默认： -XX:NewRatio=2 新生代占1，老年代2，年轻代占整个堆的1/3</p><p>-XX:NewRatio=4：新生代占1，老年代占4，年轻代占整个堆的1/5，NewRadio值就是设置老年代的占比，剩下的1个新生代</p><p>新生代特别小，会造成频繁的进行GC收集</p><h3 id="xx-maxtenuringthreshold" tabindex="-1"><a class="header-anchor" href="#xx-maxtenuringthreshold"><span>-XX:MaxTenuringThreshold</span></a></h3><p>设置垃圾最大年龄，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p><p>这里就是调整这个次数的，默认是15，并且设置的值 在 0~15之间</p><p>查看默认进入老年代年龄：jinfo -flag MaxTenuringThreshold 17344</p><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过Survivor区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概念</p>',108)],u={},g=(0,s(66262).A)(u,[["render",function(i,e){return(0,a.uX)(),(0,a.CE)("div",null,o)}]]),v=JSON.parse('{"path":"/study-notes/shangguigu-second/JVM/three.html","title":"JVM调优和参数配置","lang":"zh-CN","frontmatter":{"title":"JVM调优和参数配置","date":"2023-03-11T00:00:00.000Z","tags":["死锁"],"category":["JUC"],"description":"前言 你说你做过JVM调优和参数配置，请问如何盘点查看JVM系统默认值 使用jps和jinfo进行查看 -Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收 JVM参数类型 标配参数（从JDK1.0 - Java12都在，很稳定） -version -help java -showversion X参数（了解） -Xint：解释执行 -Xc...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-second/JVM/three.html"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"JVM调优和参数配置"}],["meta",{"property":"og:description","content":"前言 你说你做过JVM调优和参数配置，请问如何盘点查看JVM系统默认值 使用jps和jinfo进行查看 -Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收 JVM参数类型 标配参数（从JDK1.0 - Java12都在，很稳定） -version -help java -showversion X参数（了解） -Xint：解释执行 -Xc..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"死锁"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM调优和参数配置\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"JVM参数类型","slug":"jvm参数类型","link":"#jvm参数类型","children":[]},{"level":2,"title":"查看运行的Java程序，JVM参数是否开启，具体值为多少？","slug":"查看运行的java程序-jvm参数是否开启-具体值为多少","link":"#查看运行的java程序-jvm参数是否开启-具体值为多少","children":[]},{"level":2,"title":"题外话（坑题）","slug":"题外话-坑题","link":"#题外话-坑题","children":[]},{"level":2,"title":"查看JVM默认参数","slug":"查看jvm默认参数","link":"#查看jvm默认参数","children":[]},{"level":2,"title":"工作中常用的JVM基本配置参数","slug":"工作中常用的jvm基本配置参数","link":"#工作中常用的jvm基本配置参数","children":[{"level":3,"title":"查看堆内存","slug":"查看堆内存","link":"#查看堆内存","children":[]},{"level":3,"title":"打印JVM默认参数","slug":"打印jvm默认参数","link":"#打印jvm默认参数","children":[]},{"level":3,"title":"生活常用调优参数","slug":"生活常用调优参数","link":"#生活常用调优参数","children":[]},{"level":3,"title":"-XX:SurvivorRatio","slug":"xx-survivorratio","link":"#xx-survivorratio","children":[]},{"level":3,"title":"-XX:NewRatio（了解）","slug":"xx-newratio-了解","link":"#xx-newratio-了解","children":[]},{"level":3,"title":"-XX:MaxTenuringThreshold","slug":"xx-maxtenuringthreshold","link":"#xx-maxtenuringthreshold","children":[]}]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":8.38,"words":2514},"filePathRelative":"study-notes/shangguigu-second/JVM/three.md","localizedDate":"2023年3月11日","excerpt":"<h2>前言</h2>\\n<p>你说你做过JVM调优和参数配置，请问如何盘点查看JVM系统默认值</p>\\n<p>使用jps和jinfo进行查看</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>-Xms：初始堆空间</span></span>\\n<span class=\\"line\\"><span>-Xmx：堆最大值</span></span>\\n<span class=\\"line\\"><span>-Xss：栈空间</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);