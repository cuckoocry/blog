"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[6614],{6262:(e,a)=>{a.A=(e,a)=>{const n=e.__vccOpts||e;for(const[e,i]of a)n[e]=i;return n}},1458:(e,a,n)=>{n.r(a),n.d(a,{comp:()=>u,data:()=>h});var i=n(641);const s=n.p+"assets/img/image-20200310201327734.752bba26.png",l=n.p+"assets/img/image-20200310201311367.fb023b35.png",t=n.p+"assets/img/image-20200310203030720.fe58f909.png",p=n.p+"assets/img/image-20200310203350122.1f33caed.png",r=n.p+"assets/img/image-20200310210701761.57649ee6.png",c=(0,i.Fv)('<h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p>CAS的全称是Compare-And-Swap，它是CPU并发原语</p><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p><p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。</p><h2 id="代码使用" tabindex="-1"><a class="header-anchor" href="#代码使用"><span>代码使用</span></a></h2><p>首先调用AtomicInteger创建了一个实例， 并初始化为5</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        // 创建一个原子类</span></span>\n<span class="line"><span>        AtomicInteger atomicInteger = new AtomicInteger(5);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后调用CAS方法，企图更新成2019，这里有两个参数，一个是5，表示期望值，第二个就是我们要更新的值</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>atomicInteger.compareAndSet(5, 2019)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后再次使用了一个方法，同样将值改成1024</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>atomicInteger.compareAndSet(5, 1024)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>完整代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * CASDemo</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * 比较并交换：compareAndSet</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-10-19:46</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class CASDemo {</span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        // 创建一个原子类</span></span>\n<span class="line"><span>        AtomicInteger atomicInteger = new AtomicInteger(5);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        /**</span></span>\n<span class="line"><span>         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span></span>\n<span class="line"><span>         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span></span>\n<span class="line"><span>         */</span></span>\n<span class="line"><span>        System.out.println(atomicInteger.compareAndSet(5, 2019) + &quot;\\t current data: &quot; + atomicInteger.get());</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(atomicInteger.compareAndSet(5, 1024) + &quot;\\t current data: &quot; + atomicInteger.get());</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码的执行结果为</p><figure><img src="'+s+'" alt="image-20200310201327734" tabindex="0" loading="lazy"><figcaption>image-20200310201327734</figcaption></figure><p>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了2019，不满足期望值，因此返回了false，本次写入失败</p><figure><img src="'+l+'" alt="image-20200310201311367" tabindex="0" loading="lazy"><figcaption>image-20200310201311367</figcaption></figure><p>这个就类似于SVN或者Git的版本号，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p><h2 id="cas底层原理" tabindex="-1"><a class="header-anchor" href="#cas底层原理"><span>CAS底层原理</span></a></h2><p>首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p><figure><img src="'+t+'" alt="image-20200310203030720" tabindex="0" loading="lazy"><figcaption>image-20200310203030720</figcaption></figure><p>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</p><h3 id="_1、unsafe类" tabindex="-1"><a class="header-anchor" href="#_1、unsafe类"><span>1、unsafe类</span></a></h3><figure><img src="'+p+'" alt="image-20200310203350122" tabindex="0" loading="lazy"><figcaption>image-20200310203350122</figcaption></figure><p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的CAS操作的执行依赖于Unsafe类的方法。</p><p><code>注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务</code></p><p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p><h3 id="_2、变量valueoffset" tabindex="-1"><a class="header-anchor" href="#_2、变量valueoffset"><span>2、变量valueOffset</span></a></h3><p>表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</p><figure><img src="'+t+'" alt="image-20200310203030720" tabindex="0" loading="lazy"><figcaption>image-20200310203030720</figcaption></figure><p>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</p><h3 id="_3、变量value用volatile修饰" tabindex="-1"><a class="header-anchor" href="#_3、变量value用volatile修饰"><span>3、变量value用volatile修饰</span></a></h3><p>保证了多线程之间的内存可见性</p><figure><img src="'+r+'" alt="image-20200310210701761" tabindex="0" loading="lazy"><figcaption>image-20200310210701761</figcaption></figure><p>var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行compareAndSwapInt()在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p><p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p><p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值 <ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p><p>假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上）</p><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</li><li>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是线程A被挂起（该线程失去CPU执行权）</li><li>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</li><li>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while</li><li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li></ol><p>Unsafe类 + CAS思想： 也就是自旋，自我旋转</p><h2 id="底层汇编" tabindex="-1"><a class="header-anchor" href="#底层汇编"><span>底层汇编</span></a></h2><p>Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p><ul><li>先想办法拿到变量value在内存中的地址</li><li>通过Atomic::cmpxchg实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li></ul><h2 id="cas缺点" tabindex="-1"><a class="header-anchor" href="#cas缺点"><span>CAS缺点</span></a></h2><p>CAS不加锁，保证一次性，但是需要多次比较</p><ul><li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）</li><li>只能保证一个共享变量的原子操作 <ul><li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li><li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性</li></ul></li><li>引出来ABA问题？</li></ul><h2 id="aba问题" tabindex="-1"><a class="header-anchor" href="#aba问题"><span>ABA问题</span></a></h2><p>。。。。。。。。。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><h3 id="cas" tabindex="-1"><a class="header-anchor" href="#cas"><span>CAS</span></a></h3>',52),d=(0,i.Lk)("h3",{id:"cas应用",tabindex:"-1"},[(0,i.Lk)("a",{class:"header-anchor",href:"#cas应用"},[(0,i.Lk)("span",null,"CAS应用")])],-1),o=(0,i.Lk)("p",null,"CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做",-1),g={},u=(0,n(6262).A)(g,[["render",function(e,a){const n=(0,i.g2)("font");return(0,i.uX)(),(0,i.CE)("div",null,[c,(0,i.bF)(n,{color:"red"},{default:(0,i.k6)((()=>[(0,i.eW)("CAS是compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止 ")])),_:1}),d,o])}]]),h=JSON.parse('{"path":"/study-notes/shangguigu-second/CAS/","title":"2、CAS底层原理","lang":"zh-CN","frontmatter":{"title":"2、CAS底层原理","date":"2023-03-11T00:00:00.000Z","tags":["JUC","CAS"],"category":["JUC"],"description":"概念 CAS的全称是Compare-And-Swap，它是CPU并发原语 它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的 CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-second/CAS/"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"2、CAS底层原理"}],["meta",{"property":"og:description","content":"概念 CAS的全称是Compare-And-Swap，它是CPU并发原语 它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的 CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:tag","content":"CAS"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2、CAS底层原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"代码使用","slug":"代码使用","link":"#代码使用","children":[]},{"level":2,"title":"CAS底层原理","slug":"cas底层原理","link":"#cas底层原理","children":[{"level":3,"title":"1、unsafe类","slug":"_1、unsafe类","link":"#_1、unsafe类","children":[]},{"level":3,"title":"2、变量valueOffset","slug":"_2、变量valueoffset","link":"#_2、变量valueoffset","children":[]},{"level":3,"title":"3、变量value用volatile修饰","slug":"_3、变量value用volatile修饰","link":"#_3、变量value用volatile修饰","children":[]}]},{"level":2,"title":"底层汇编","slug":"底层汇编","link":"#底层汇编","children":[]},{"level":2,"title":"CAS缺点","slug":"cas缺点","link":"#cas缺点","children":[]},{"level":2,"title":"ABA问题","slug":"aba问题","link":"#aba问题","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[{"level":3,"title":"CAS","slug":"cas","link":"#cas","children":[]},{"level":3,"title":"CAS应用","slug":"cas应用","link":"#cas应用","children":[]}]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":6.53,"words":1959},"filePathRelative":"study-notes/shangguigu-second/CAS/README.md","localizedDate":"2023年3月11日","excerpt":"<h2>概念</h2>\\n<p>CAS的全称是Compare-And-Swap，它是CPU并发原语</p>\\n<p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p>\\n<p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。</p>","autoDesc":true}')}}]);