"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[2334],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}},53064:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>d,data:()=>c});var i=a(20641);const e=a.p+"assets/img/image-20200318175441578.31b31034.png",l=a.p+"assets/img/image-20200318181504703.8b673d2a.png",p=[(0,i.Fv)('<p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种<code>互相等待的现象</code>，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><figure><img src="'+e+'" alt="image-20200318175441578" tabindex="0" loading="lazy"><figcaption>image-20200318175441578</figcaption></figure><h2 id="产生死锁的原因" tabindex="-1"><a class="header-anchor" href="#产生死锁的原因"><span>产生死锁的原因</span></a></h2><ul><li>系统资源不足</li><li>进程运行推进的顺序不对</li><li>资源分配不当</li></ul><h2 id="死锁产生的四个必要条件" tabindex="-1"><a class="header-anchor" href="#死锁产生的四个必要条件"><span>死锁产生的四个必要条件</span></a></h2><ul><li>互斥 <ul><li>解决方法：把互斥的共享资源封装成可同时访问</li></ul></li><li>占有且等待 <ul><li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li></ul></li><li>非抢占式 <ul><li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li></ul></li><li>循环等待 <ul><li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li></ul></li></ul><h2 id="死锁代码" tabindex="-1"><a class="header-anchor" href="#死锁代码"><span>死锁代码</span></a></h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 死锁小Demo</span></span>\n<span class="line"><span> * 死锁是指两个或多个以上的进程在执行过程中，</span></span>\n<span class="line"><span> * 因争夺资源而造成一种互相等待的现象，</span></span>\n<span class="line"><span> * 若无外力干涉那他们都将无法推进下去</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-18-17:58</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>import java.util.concurrent.TimeUnit;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span> * 资源类</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>class HoldLockThread implements Runnable{</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private String lockA;</span></span>\n<span class="line"><span>    private String lockB;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 持有自己的锁，还想得到别人的锁</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public HoldLockThread(String lockA, String lockB) {</span></span>\n<span class="line"><span>        this.lockA = lockA;</span></span>\n<span class="line"><span>        this.lockB = lockB;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    @Override</span></span>\n<span class="line"><span>    public void run() {</span></span>\n<span class="line"><span>        synchronized (lockA) {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t 自己持有&quot; + lockA + &quot;\\t 尝试获取：&quot; + lockB);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                TimeUnit.SECONDS.sleep(2);</span></span>\n<span class="line"><span>            } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            synchronized (lockB) {</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t 自己持有&quot; + lockB + &quot;\\t 尝试获取：&quot; + lockA);</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>public class DeadLockDemo {</span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        String lockA = &quot;lockA&quot;;</span></span>\n<span class="line"><span>        String lockB = &quot;lockB&quot;;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        new Thread(new HoldLockThread(lockA, lockB), &quot;t1&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        new Thread(new HoldLockThread(lockB, lockA), &quot;t2&quot;).start();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果，main线程无法结束</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t1\t 自己持有lockA\t 尝试获取：lockB</span></span>\n<span class="line"><span>t2\t 自己持有lockB\t 尝试获取：lockA</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何排查死锁" tabindex="-1"><a class="header-anchor" href="#如何排查死锁"><span>如何排查死锁</span></a></h2><p>当我们出现死锁的时候，首先需要使用jps命令查看运行的程序</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jps -l</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们能看到DeadLockDemo这个类，一直在运行</p><figure><img src="'+l+'" alt="image-20200318181504703" tabindex="0" loading="lazy"><figcaption>image-20200318181504703</figcaption></figure><p>在使用jstack查看堆栈信息</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jstack  7560   # 后面参数是 jps输出的该类的pid</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>得到的结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Found one Java-level deadlock:</span></span>\n<span class="line"><span>=============================</span></span>\n<span class="line"><span>&quot;t2&quot;:</span></span>\n<span class="line"><span>  waiting to lock monitor 0x000000001cfc0de8 (object 0x000000076b696e80, a java.lang.String),</span></span>\n<span class="line"><span>  which is held by &quot;t1&quot;</span></span>\n<span class="line"><span>&quot;t1&quot;:</span></span>\n<span class="line"><span>  waiting to lock monitor 0x000000001cfc3728 (object 0x000000076b696eb8, a java.lang.String),</span></span>\n<span class="line"><span>  which is held by &quot;t2&quot;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Java stack information for the threads listed above:</span></span>\n<span class="line"><span>===================================================</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>&quot;DestroyJavaVM&quot; #14 prio=5 os_prio=0 tid=0x0000000003674000 nid=0x386c waiting on condition [0x0000000000000000]</span></span>\n<span class="line"><span>   java.lang.Thread.State: RUNNABLE</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>&quot;t2&quot; #13 prio=5 os_prio=0 tid=0x000000001a81c800 nid=0x16cc waiting for monitor entry [0x000000001b64f000]</span></span>\n<span class="line"><span>   java.lang.Thread.State: BLOCKED (on object monitor)</span></span>\n<span class="line"><span>        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:42)</span></span>\n<span class="line"><span>        - waiting to lock &lt;0x00000000d5e78748&gt; (a java.lang.String)</span></span>\n<span class="line"><span>        - locked &lt;0x00000000d5e78780&gt; (a java.lang.String)</span></span>\n<span class="line"><span>        at java.lang.Thread.run(Thread.java:748)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>&quot;t1&quot; #12 prio=5 os_prio=0 tid=0x000000001a81b800 nid=0x4168 waiting for monitor entry [0x000000001b54f000]</span></span>\n<span class="line"><span>   java.lang.Thread.State: BLOCKED (on object monitor)</span></span>\n<span class="line"><span>        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:42)</span></span>\n<span class="line"><span>        - waiting to lock &lt;0x00000000d5e78780&gt; (a java.lang.String)</span></span>\n<span class="line"><span>        - locked &lt;0x00000000d5e78748&gt; (a java.lang.String)</span></span>\n<span class="line"><span>        at java.lang.Thread.run(Thread.java:748)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Found 1 deadlock.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过查看最后一行，我们看到 Found 1 deadlock，即存在一个死锁</p><p>命令总结：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># jps命令查看运行的程序</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">jps</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -l</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># jstack查看堆栈信息    # 后面参数是 jps输出的该类的pid</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">jstack</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  进程编号</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',23)],t={},d=(0,a(66262).A)(t,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,p)}]]),c=JSON.parse('{"path":"/study-notes/shangguigu-second/SiSuo/","title":"10、死锁编码及定位分析","lang":"zh-CN","frontmatter":{"title":"10、死锁编码及定位分析","date":"2023-03-11T00:00:00.000Z","tags":["死锁"],"category":["JUC"],"description":"死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。 image-20200318175441578image-20200318175441578 产生死锁的原因 系统资源不足 进程运行推...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/./study-notes/shangguigu-second/SiSuo/"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"10、死锁编码及定位分析"}],["meta",{"property":"og:description","content":"死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。 image-20200318175441578image-20200318175441578 产生死锁的原因 系统资源不足 进程运行推..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"死锁"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"10、死锁编码及定位分析\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"产生死锁的原因","slug":"产生死锁的原因","link":"#产生死锁的原因","children":[]},{"level":2,"title":"死锁产生的四个必要条件","slug":"死锁产生的四个必要条件","link":"#死锁产生的四个必要条件","children":[]},{"level":2,"title":"死锁代码","slug":"死锁代码","link":"#死锁代码","children":[]},{"level":2,"title":"如何排查死锁","slug":"如何排查死锁","link":"#如何排查死锁","children":[]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":2.93,"words":879},"filePathRelative":"study-notes/shangguigu-second/SiSuo/README.md","localizedDate":"2023年3月11日","excerpt":"<p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种<code>互相等待的现象</code>，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>\\n<figure><figcaption>image-20200318175441578</figcaption></figure>\\n<h2>产生死锁的原因</h2>\\n<ul>\\n<li>系统资源不足</li>\\n<li>进程运行推进的顺序不对</li>\\n<li>资源分配不当</li>\\n</ul>\\n<h2>死锁产生的四个必要条件</h2>\\n<ul>\\n<li>互斥\\n<ul>\\n<li>解决方法：把互斥的共享资源封装成可同时访问</li>\\n</ul>\\n</li>\\n<li>占有且等待\\n<ul>\\n<li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li>\\n</ul>\\n</li>\\n<li>非抢占式\\n<ul>\\n<li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li>\\n</ul>\\n</li>\\n<li>循环等待\\n<ul>\\n<li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')}}]);