"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[7837],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}},53641:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>o,data:()=>u});var i=a(20641);const e=a.p+"assets/img/20200918001.e91123cc.png",l=a.p+"assets/img/image-20210918004235683.dcbf764d.png",p=a.p+"assets/img/image-20210918004625875.fd91fdd4.png",c=a.p+"assets/img/image-20210918004651333.3d42efcc.png",t=a.p+"assets/img/image-20210918005456247.225eaeda.png",d=[(0,i.Fv)('<h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的的内层方法会自动获取锁（前提是锁对象得是同一个对象），不会因为之前已经获取过还没释放而阻塞。</p><p>Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><p>将字分开解释：</p><ul><li>可：可以</li><li>重：再次</li><li>入：进入</li><li>锁：同步锁</li><li>进入什么？ - 进入同步域（即同步代码块/方法或显示锁锁定的代码）</li></ul><p>一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。</p><p>自己可以获取自己的内部锁。</p><h2 id="可重入锁的种类" tabindex="-1"><a class="header-anchor" href="#可重入锁的种类"><span>可重入锁的种类</span></a></h2><ul><li>隐式锁（即synchronized关键字使用的锁）默认是可重入锁。 <ul><li>同步代码块</li><li>同步方法</li></ul></li><li>Synchronized的重入的实现机理。</li><li>显式锁（即Lock）也有ReentrantLock这样的可重入锁。</li></ul><p>隐式锁（synchronized关键字使用的锁）默认是可重入锁</p><h3 id="synchronized的同步方法" tabindex="-1"><a class="header-anchor" href="#synchronized的同步方法"><span>synchronized的同步方法</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * @Description： 可重入锁</span></span>\n<span class="line"><span> * &lt;p&gt;</span></span>\n<span class="line"><span> * 可重入锁:可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。</span></span>\n<span class="line"><span> * &lt;p&gt;</span></span>\n<span class="line"><span> * 在一个synchronized修饰的方法或代码块的内部</span></span>\n<span class="line"><span> * 调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class ReEnterLockDemo {</span></span>\n<span class="line"><span>    static Object objectlockA = new Object();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void m1() {</span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + &quot;---外层调用&quot;);</span></span>\n<span class="line"><span>            synchronized (objectlockA) {</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + &quot;---中层调用&quot;);</span></span>\n<span class="line"><span>                synchronized (objectlockA) {</span></span>\n<span class="line"><span>                    System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + &quot;---内层调用&quot;);</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;t1&quot;).start();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        m1();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="" tabindex="-1"><a class="header-anchor" href="#"><span><img src="'+e+'" alt="img" loading="lazy"></span></a></h3><p>synchronized的同步方法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span>public class ReEnterLockDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public synchronized void m1() {</span></span>\n<span class="line"><span>        System.out.println(&quot;===外&quot;);</span></span>\n<span class="line"><span>        m2();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public synchronized void m2() {</span></span>\n<span class="line"><span>        System.out.println(&quot;===中&quot;);</span></span>\n<span class="line"><span>        m3();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public synchronized void m3() {</span></span>\n<span class="line"><span>        System.out.println(&quot;===内&quot;);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        new ReEnterLockDemo().m1();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+l+'" alt="image-20210918004235683" tabindex="0" loading="lazy"><figcaption>image-20210918004235683</figcaption></figure><p><strong>Synchronized的重入的实现机理</strong></p><p>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</p><p>当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p><p>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p><p>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</p><figure><img src="'+p+'" alt="image-20210918004625875" tabindex="0" loading="lazy"><figcaption>image-20210918004625875</figcaption></figure><figure><img src="'+c+'" alt="image-20210918004651333" tabindex="0" loading="lazy"><figcaption>image-20210918004651333</figcaption></figure><p><strong>为什么多出来一个，不配对？？</strong></p><p>异常时保证彻底释放锁和退出。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>\n<span class="line"><span>public class ReEnterLockDemo3 {</span></span>\n<span class="line"><span>    static Lock lock = new ReentrantLock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            lock.lock();</span></span>\n<span class="line"><span>            //lock.lock();</span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                System.out.println(&quot;=======外层调用&quot;);</span></span>\n<span class="line"><span>                lock.lock();</span></span>\n<span class="line"><span>                try {</span></span>\n<span class="line"><span>                    System.out.println(&quot;=======内层调用&quot;);</span></span>\n<span class="line"><span>                } finally {</span></span>\n<span class="line"><span>                    lock.unlock();</span></span>\n<span class="line"><span>//                    lock.unlock();</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            } finally {</span></span>\n<span class="line"><span>                //实现加锁次数和释放次数不一样</span></span>\n<span class="line"><span>                //由于加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直在等待。</span></span>\n<span class="line"><span>                lock.unlock();</span></span>\n<span class="line"><span>                //lock.unlock();    //正在情况，加锁几次就要解锁几次</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;t1&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            lock.lock();</span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                System.out.println(&quot;b thread----外层调用lock&quot;);</span></span>\n<span class="line"><span>            } catch (Exception e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            } finally {</span></span>\n<span class="line"><span>                lock.unlock();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;b&quot;).start();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+t+'" alt="image-20210918005456247" tabindex="0" loading="lazy"><figcaption>image-20210918005456247</figcaption></figure>',27)],r={},o=(0,a(66262).A)(r,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,d)}]]),u=JSON.parse('{"path":"/study-notes/shangguigu-three/ReentrantLock/","title":"可重入锁理论","lang":"zh-CN","frontmatter":{"title":"可重入锁理论","date":"2023-03-11T00:00:00.000Z","description":"定义 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的的内层方法会自动获取锁（前提是锁对象得是同一个对象），不会因为之前已经获取过还没释放而阻塞。 Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。 将字分开解释： 可：可以 重：再次 入：进入 锁：同步锁 进入...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/study-notes/shangguigu-three/ReentrantLock/"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"可重入锁理论"}],["meta",{"property":"og:description","content":"定义 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的的内层方法会自动获取锁（前提是锁对象得是同一个对象），不会因为之前已经获取过还没释放而阻塞。 Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。 将字分开解释： 可：可以 重：再次 入：进入 锁：同步锁 进入..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:24:55.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:24:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"可重入锁理论\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:24:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":2,"title":"可重入锁的种类","slug":"可重入锁的种类","link":"#可重入锁的种类","children":[{"level":3,"title":"synchronized的同步方法","slug":"synchronized的同步方法","link":"#synchronized的同步方法","children":[]},{"level":3,"title":"","slug":"","link":"#","children":[]}]}],"git":{"createdTime":1722090295000,"updatedTime":1722090295000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":2.84,"words":851},"filePathRelative":"study-notes/shangguigu-three/ReentrantLock/README.md","localizedDate":"2023年3月11日","excerpt":"<h2>定义</h2>\\n<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的的内层方法会自动获取锁（前提是锁对象得是同一个对象），不会因为之前已经获取过还没释放而阻塞。</p>\\n<p>Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>\\n<p>将字分开解释：</p>\\n<ul>\\n<li>可：可以</li>\\n<li>重：再次</li>\\n<li>入：进入</li>\\n<li>锁：同步锁</li>\\n<li>进入什么？ - 进入同步域（即同步代码块/方法或显示锁锁定的代码）</li>\\n</ul>\\n<p>一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。</p>","autoDesc":true}')}}]);