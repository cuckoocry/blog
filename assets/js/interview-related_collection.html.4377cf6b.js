"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[2174],{66262:(e,a)=>{a.A=(e,a)=>{const o=e.__vccOpts||e;for(const[e,i]of a)o[e]=i;return o}},69367:(e,a,o)=>{o.r(a),o.d(a,{comp:()=>r,data:()=>s});var i=o(20641);const l=[(0,i.Fv)('<div class="hint-container tip"><p class="hint-container-title">提示</p><p>Be a better version of yourself</p></div><h2 id="list" tabindex="-1"><a class="header-anchor" href="#list"><span>List</span></a></h2><h3 id="_1、arraylist-和-array-数组-的区别" tabindex="-1"><a class="header-anchor" href="#_1、arraylist-和-array-数组-的区别"><span>1、ArrayList 和 Array（数组）的区别？</span></a></h3><p><code>ArrayList</code>内部基于动态数组实现，比<code> Array</code>（静态数组） 使用起来更加灵活 ：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储<strong>对象</strong>。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h3 id="_2、-arraylist扩容规则" tabindex="-1"><a class="header-anchor" href="#_2、-arraylist扩容规则"><span>2、 <code>ArrayList</code>扩容规则</span></a></h3><p><strong>扩容规则</strong></p><ol><li><p><code>ArrayList()</code>,以无参数构造方法创建<code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</p></li><li><p><code>ArrayList(int initialCapacity)</code> 会使用指定容量的数组</p></li><li><p><code>public ArrayList(Collection&lt;? extends E&gt; c) </code>会使用 c 的大小作为数组容量</p></li><li><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p></li><li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p></li></ol><blockquote><p>复制旧数组：扩容后，ArrayList 会将原来的数组内容复制到新数组中。</p></blockquote><blockquote><p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</p></blockquote><blockquote><p>&quot;&gt;&gt;&quot;（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。</p></blockquote><h3 id="_3、-arraylist-对比-linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#_3、-arraylist-对比-linkedlist的区别"><span>3、 <code>ArrayList</code> 对比 <code>LinkedList</code>的区别</span></a></h3><p><strong>LinkedList</strong></p><ol><li>基于双向链表，无需连续内存</li><li>随机访问慢（要沿着链表遍历）</li><li>头尾插入删除性能高</li><li>占用内存多</li></ol><p><strong>ArrayList</strong></p><ol><li>基于数组，需要连续内存</li><li>随机访问快（指根据下标访问）</li><li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li><li>可以利用 cpu 缓存，局部性原理</li></ol><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map"><span>Map</span></a></h2><h3 id="_1、hashmap的基本数据结构" tabindex="-1"><a class="header-anchor" href="#_1、hashmap的基本数据结构"><span>1、<code>HashMap</code>的基本数据结构</span></a></h3><ul><li>1.7 数组 + 链表</li><li>1.8 数组 + （链表 | 红黑树）</li></ul><p>拿到key,拿到key的hashCode，二次hsah,与数组容量减一去按位与（ <code>(n - 1) &amp; hash</code>），计算出key的索引位置，也就是桶下标。</p><h3 id="_2、hashmap的树化" tabindex="-1"><a class="header-anchor" href="#_2、hashmap的树化"><span>2、<code>HashMap</code>的树化</span></a></h3><p><strong>树化意义</strong>：</p><ul><li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略 <ul><li>hash 表的查找，更新的时间复杂度是 <code>O(1)</code>，而红黑树的查找，更新的时间复杂度是 <code>O(log_2⁡n )</code>，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li><li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006(一亿分之6)，树化阈值选择 8 就是为了让树化几率足够小</li></ul></li></ul><p><strong>树化规则</strong>：</p><p>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;=64，才会进行树化。</p><blockquote><p>注：链表长度可能超过8的。</p></blockquote><p><strong>树退化规则</strong>：</p><ul><li>情况1：在扩容时如果拆分树时，树元素个数 &lt;= 6 则会退化链表</li><li>情况2：remove 树节点时，（移除之前判断）若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul><h3 id="_3、hashmap索引计算" tabindex="-1"><a class="header-anchor" href="#_3、hashmap索引计算"><span>3、<code>HashMap</code>索引计算</span></a></h3><h4 id="索引计算方法" tabindex="-1"><a class="header-anchor" href="#索引计算方法"><span>索引计算方法</span></a></h4><p><code>HashMap</code> 通过 <code>key</code> 的 <code>hashcode</code> 经过扰动函数(<code>hash()</code> 方法)处理过后得到 <code>hash</code> 值， 然后通过<code> (n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），</p><blockquote><p>二次 hash() 是为了综合高位数据，让哈希分布更为均匀.</p></blockquote><blockquote><p>一句话总结，key的hashcode二次哈希得到hash值，hash值与数组长度减一位与运算。<code>&amp;</code></p></blockquote><h4 id="数组容量为何是-2-的-n-次幂" tabindex="-1"><a class="header-anchor" href="#数组容量为何是-2-的-n-次幂"><span>数组容量为何是 2 的 n 次幂</span></a></h4><ol><li>计算索引时效率更高：位运算(&amp;)比取余运算(%)更高效。当长度为 2 的幂次方时，<code>hash % lengt</code>h 等价于 <code>hash &amp; (length - 1)</code>。</li><li><strong>扩容时重新计算索引效率更高</strong>： <code>hash &amp; oldCap（旧容量） == 0 </code>的元素留在原来位置 ，否则<code>新位置 = 旧位置 + oldCap</code></li><li>可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。</li></ol><p><strong>注意</strong></p><ul><li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li><li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li></ul><h4 id="put-与扩容" tabindex="-1"><a class="header-anchor" href="#put-与扩容"><span>put 与扩容</span></a></h4><p>put 流程:</p><ol><li>HashMap 是懒惰创建数组的，首次使用才创建数组</li><li>计算索引（桶下标）。（拿到key的hashCode，二次hsah,与数组容量减一去按位与，计算出key的索引位置，也就是桶下标）</li><li>如果桶下标还没人占用，创建 Node 占位返回。键值对插入该位置</li><li>如果桶下标已经有人占用</li><li>已经是 TreeNode 走红黑树的添加或更新逻辑</li><li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li><li>返回前检查容量是否超过阈值，一旦超过进行扩容</li></ol><p><strong>1.7 与 1.8 的区别</strong></p><ol><li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p></li><li><p>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</p></li><li><p>1.8 在扩容计算 Node 索引时，会优化</p></li></ol><p><code>HashMap</code> 的扩容机制：</p><ol><li>初始容量：HashMap 的默认初始容量是 16，加载因子（load factor）为 0.75。</li><li>触发扩容：当 HashMap 中的元素数量超过<code>容量 * 加载因子</code> 时，会触发扩容。例如，默认情况下，当 HashMap 中的元素数量超过 12（16 * 0.75）时，就会进行扩容。</li><li>扩容过程：</li></ol><ul><li>扩容时，HashMap 会将容量翻倍，并重新计算所有已有元素的索引位置，将它们重新分配到新的数组中。</li><li>在重新分配时，由于数组长度的变化，元素的位置可能会改变，因此需要重新计算哈希值和索引位置，这个过程称为 <code>rehashing</code>。</li></ul><p><strong>扩容（加载）因子为何默认是 0.75f</strong></p><ol><li>在空间占用与查询时间之间取得较好的权衡</li><li>大于这个值，空间节省了，但链表就会比较长影响性能</li><li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li></ol>',47)],t={},r=(0,o(66262).A)(t,[["render",function(e,a){return(0,i.uX)(),(0,i.CE)("div",null,l)}]]),s=JSON.parse('{"path":"/interview-related/collection.html","title":"面试指南-Java集合框架","lang":"zh-CN","frontmatter":{"title":"面试指南-Java集合框架","category":"面试指南","order":2,"description":"提示 Be a better version of yourself List 1、ArrayList 和 Array（数组）的区别？ ArrayList内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活 ： ArrayList会根据实际存储的元素动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。 ArrayList 允...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/interview-related/collection.html"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"面试指南-Java集合框架"}],["meta",{"property":"og:description","content":"提示 Be a better version of yourself List 1、ArrayList 和 Array（数组）的区别？ ArrayList内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活 ： ArrayList会根据实际存储的元素动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。 ArrayList 允..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-02T14:01:30.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:modified_time","content":"2024-09-02T14:01:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试指南-Java集合框架\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-02T14:01:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"List","slug":"list","link":"#list","children":[{"level":3,"title":"1、ArrayList 和 Array（数组）的区别？","slug":"_1、arraylist-和-array-数组-的区别","link":"#_1、arraylist-和-array-数组-的区别","children":[]},{"level":3,"title":"2、 ArrayList扩容规则","slug":"_2、-arraylist扩容规则","link":"#_2、-arraylist扩容规则","children":[]},{"level":3,"title":"3、 ArrayList 对比 LinkedList的区别","slug":"_3、-arraylist-对比-linkedlist的区别","link":"#_3、-arraylist-对比-linkedlist的区别","children":[]}]},{"level":2,"title":"Map","slug":"map","link":"#map","children":[{"level":3,"title":"1、HashMap的基本数据结构","slug":"_1、hashmap的基本数据结构","link":"#_1、hashmap的基本数据结构","children":[]},{"level":3,"title":"2、HashMap的树化","slug":"_2、hashmap的树化","link":"#_2、hashmap的树化","children":[]},{"level":3,"title":"3、HashMap索引计算","slug":"_3、hashmap索引计算","link":"#_3、hashmap索引计算","children":[]}]}],"git":{"createdTime":1722072119000,"updatedTime":1725285690000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":2}]},"readingTime":{"minutes":6.27,"words":1881},"filePathRelative":"interview-related/collection.md","localizedDate":"2024年7月27日","excerpt":"<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p>Be a better version of yourself</p>\\n</div>\\n<h2>List</h2>\\n<h3>1、ArrayList 和 Array（数组）的区别？</h3>\\n<p><code>ArrayList</code>内部基于动态数组实现，比<code> Array</code>（静态数组） 使用起来更加灵活 ：</p>\\n<ul>\\n<li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li>\\n<li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li>\\n<li><code>ArrayList</code> 中只能存储<strong>对象</strong>。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li>\\n<li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li>\\n<li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li>\\n</ul>","autoDesc":true}')}}]);