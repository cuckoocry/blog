"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[152],{66262:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,a]of t)i[e]=a;return i}},23309:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>c,data:()=>m});var a=i(20641);const n=i.p+"assets/img/image-20200705111640511.b7c4049a.png",p=i.p+"assets/img/image-20200705111843003.e9eed063.png",o=i.p+"assets/img/image-20200705112036630.e2e93447.png",r=i.p+"assets/img/image-20200705112416101.4a02e1a3.png",g=i.p+"assets/img/image-20200705112601211.139ec35d.png",l=[(0,a.Fv)('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><figure><img src="'+n+'" alt="image-20200705111640511" tabindex="0" loading="lazy"><figcaption>image-20200705111640511</figcaption></figure><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><figure><img src="'+p+'" alt="image-20200705111843003" tabindex="0" loading="lazy"><figcaption>image-20200705111843003</figcaption></figure><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><figure><img src="'+o+'" alt="image-20200705112036630" tabindex="0" loading="lazy"><figcaption>image-20200705112036630</figcaption></figure><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p><blockquote><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></blockquote><p>运行时数据区的完整图</p><figure><img src="'+r+'" alt="image-20200705112416101" tabindex="0" loading="lazy"><figcaption>image-20200705112416101</figcaption></figure><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><figure><img src="'+g+'" alt="image-20200705112601211" tabindex="0" loading="lazy"><figcaption>image-20200705112601211</figcaption></figure><h2 id="线程" tabindex="-1"><a class="header-anchor" href="#线程"><span>线程</span></a></h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p><h3 id="jvm系统线程" tabindex="-1"><a class="header-anchor" href="#jvm系统线程"><span>JVM系统线程</span></a></h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。| 这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括&quot;stop-the-world&quot;的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><h3 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h3>',23)],s={},c=(0,i(66262).A)(s,[["render",function(e,t){return(0,a.uX)(),(0,a.CE)("div",null,l)}]]),m=JSON.parse('{"path":"/study-notes/JVM/Memory-GC/JVM-RuntimeDataAreas/","title":"运行时数据区概述及线程","lang":"zh-CN","frontmatter":{"title":"运行时数据区概述及线程","date":"2023-03-18T00:00:00.000Z","tags":["JVM"],"description":"前言 本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段 image-20200705111640511image-20200705111640511 当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区 image-...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/study-notes/JVM/Memory-GC/JVM-RuntimeDataAreas/"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"运行时数据区概述及线程"}],["meta",{"property":"og:description","content":"前言 本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段 image-20200705111640511image-20200705111640511 当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区 image-..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-11T14:34:32.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2023-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-11T14:34:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"运行时数据区概述及线程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-11T14:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"线程","slug":"线程","link":"#线程","children":[{"level":3,"title":"JVM系统线程","slug":"jvm系统线程","link":"#jvm系统线程","children":[]},{"level":3,"title":"","slug":"","link":"#","children":[]}]}],"git":{"createdTime":1723381883000,"updatedTime":1723386872000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":2}]},"readingTime":{"minutes":3.41,"words":1023},"filePathRelative":"study-notes/JVM/Memory-GC/JVM-RuntimeDataAreas/README.md","localizedDate":"2023年3月18日","excerpt":"<h2>前言</h2>\\n<p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>\\n<figure><figcaption>image-20200705111640511</figcaption></figure>\\n<p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>\\n<figure><figcaption>image-20200705111843003</figcaption></figure>\\n<p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p>","autoDesc":true}')}}]);