"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[9088],{6262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},1591:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>c,data:()=>d});var e=a(641);const i=a.p+"assets/img/image-20200315154143781.92faa896.png",l=(0,e.Fv)('<p>原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p><figure><img src="'+i+'" alt="image-20200315154143781" tabindex="0" loading="lazy"><figcaption>image-20200315154143781</figcaption></figure><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h2><p>优点：循环比较获取直到成功为止，没有类似于wait的阻塞</p><p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p><h2 id="手写自旋锁" tabindex="-1"><a class="header-anchor" href="#手写自旋锁"><span>手写自旋锁</span></a></h2><p>通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span> * 题目：手写一个自旋锁</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * 优点：循环比较获取直到成功为止，没有类似于wait的阻塞</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-01-21:22</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class SpinLockDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 现在的泛型装的是Thread，原子引用线程</span></span>\n<span class="line"><span>    AtomicReference&lt;Thread&gt;  atomicReference = new AtomicReference&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void myLock() {</span></span>\n<span class="line"><span>        // 获取当前进来的线程</span></span>\n<span class="line"><span>        Thread thread = Thread.currentThread();</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t come in (●&#39;◡&#39;●)&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋</span></span>\n<span class="line"><span>        while (!atomicReference.compareAndSet(null, thread)){</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 解锁</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public void myUnLock() {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 获取当前进来的线程</span></span>\n<span class="line"><span>        Thread thread = Thread.currentThread();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 自己用完了后，把atomicReference变成null</span></span>\n<span class="line"><span>        atomicReference.compareAndSet(thread, null);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t invoked myUnlock()&quot;);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        SpinLockDemo spinLockDemo = new SpinLockDemo();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 启动t1线程，开始操作</span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            // 开始占有锁</span></span>\n<span class="line"><span>            spinLockDemo.myLock();</span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                // 持有5秒</span></span>\n<span class="line"><span>                TimeUnit.SECONDS.sleep(5);</span></span>\n<span class="line"><span>            } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 开始释放锁</span></span>\n<span class="line"><span>            spinLockDemo.myUnLock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        }, &quot;t1&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 让main线程暂停1秒，使得t1线程，先执行</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            TimeUnit.SECONDS.sleep(1);</span></span>\n<span class="line"><span>        } catch (InterruptedException e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 1秒后，启动t2线程，开始占用这个锁</span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 开始占有锁  （t2进去就等着）</span></span>\n<span class="line"><span>            spinLockDemo.myLock();</span></span>\n<span class="line"><span>            // 开始释放锁</span></span>\n<span class="line"><span>            spinLockDemo.myUnLock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        }, &quot;t2&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后输出结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t1 come in</span></span>\n<span class="line"><span>.....一秒后.....</span></span>\n<span class="line"><span>t2 come in</span></span>\n<span class="line"><span>.....五秒后.....</span></span>\n<span class="line"><span>t1 invoked myUnlock()</span></span>\n<span class="line"><span>t2 invoked myUnlock()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、首先输出的是 t1 come in<br> 2、然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行 compareAndSet方法（自选），来进行比较。<br> 3、直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放。</p>',11),p={},c=(0,a(6262).A)(p,[["render",function(n,s){const a=(0,e.g2)("font");return(0,e.uX)(),(0,e.CE)("div",null,[(0,e.Lk)("p",null,[(0,e.eW)("自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是"),(0,e.bF)(a,{color:"red"},{default:(0,e.k6)((()=>[(0,e.eW)("采用循环的方式去尝试获取锁")])),_:1}),(0,e.eW)("，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU")]),l])}]]),d=JSON.parse('{"path":"/study-notes/shangguigu-second/lock/four.html","title":"Java锁之自旋锁","lang":"zh-CN","frontmatter":{"title":"Java锁之自旋锁","date":"2023-03-18T00:00:00.000Z","tags":["锁"],"category":["学习笔记"],"description":"自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU 原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。 image-20200315154143781image-20200315154143781 优缺点 优点：循环比较获取直到成功为...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-second/lock/four.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"Java锁之自旋锁"}],["meta",{"property":"og:description","content":"自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU 原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。 image-20200315154143781image-20200315154143781 优缺点 优点：循环比较获取直到成功为..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:published_time","content":"2023-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java锁之自旋锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]},{"level":2,"title":"手写自旋锁","slug":"手写自旋锁","link":"#手写自旋锁","children":[]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":2.37,"words":710},"filePathRelative":"study-notes/shangguigu-second/lock/four.md","localizedDate":"2023年3月18日","excerpt":"<p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>\\n<p>原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p>\\n<figure><figcaption>image-20200315154143781</figcaption></figure>\\n<h2>优缺点</h2>\\n<p>优点：循环比较获取直到成功为止，没有类似于wait的阻塞</p>\\n<p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p>\\n<h2>手写自旋锁</h2>","autoDesc":true}')}}]);