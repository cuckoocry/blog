"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[5610],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},1047:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>r,data:()=>v});var e=a(20641);const i=(0,e.Lk)("h2",{id:"概念",tabindex:"-1"},[(0,e.Lk)("a",{class:"header-anchor",href:"#概念"},[(0,e.Lk)("span",null,"概念")])],-1),l=(0,e.Lk)("p",null,"可重入锁就是递归锁",-1),p=(0,e.Lk)("p",null,"指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁",-1),c=(0,e.Lk)("code",null,"线程可以进入任何一个它已经拥有的锁所同步的代码块",-1),d=(0,e.Fv)('<p><strong>ReentrantLock / Synchronized 就是一个典型的可重入锁</strong></p><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码"><span>代码</span></a></h2><p>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public synchronized void method1() {</span></span>\n<span class="line"><span>\tmethod2();</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>public synchronized void method2() {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。</p><h2 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h2><p><strong>可重入锁的最大作用就是避免死锁</strong></p><h2 id="可重入锁验证" tabindex="-1"><a class="header-anchor" href="#可重入锁验证"><span>可重入锁验证</span></a></h2><h3 id="证明synchronized" tabindex="-1"><a class="header-anchor" href="#证明synchronized"><span>证明Synchronized</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 可重入锁（也叫递归锁）</span></span>\n<span class="line"><span> * 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * 也就是说：`线程可以进入任何一个它已经拥有的锁所同步的代码块`</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2023-03-01-21:17</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span> * 资源类</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>class Phone {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 发送短信</span></span>\n<span class="line"><span>     * @throws Exception</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public synchronized void sendSMS() throws Exception{</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t invoked sendSMS()&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 在同步方法中，调用另外一个同步方法</span></span>\n<span class="line"><span>        sendEmail();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 发邮件</span></span>\n<span class="line"><span>     * @throws Exception</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public synchronized void sendEmail() throws Exception{</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getId() + &quot;\\t invoked sendEmail()&quot;);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>public class ReenterLockDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        Phone phone = new Phone();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 两个线程操作资源列</span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                phone.sendSMS();</span></span>\n<span class="line"><span>            } catch (Exception e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;t1&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                phone.sendSMS();</span></span>\n<span class="line"><span>            } catch (Exception e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;t2&quot;).start();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t1\t invoked sendSMS()</span></span>\n<span class="line"><span>t1\t invoked sendEmail()</span></span>\n<span class="line"><span>t2\t invoked sendSMS()</span></span>\n<span class="line"><span>t2\t invoked sendEmail()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t1\t invoked sendSMS()      t1线程在外层方法获取锁的时候</span></span>\n<span class="line"><span>t1\t invoked sendEmail()    t1在进入内层方法会自动获取锁</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>t2\t invoked sendSMS()      t2线程在外层方法获取锁的时候</span></span>\n<span class="line"><span>t2\t invoked sendEmail()    t2在进入内层方法会自动获取锁</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="证明reentrantlock" tabindex="-1"><a class="header-anchor" href="#证明reentrantlock"><span>证明ReentrantLock</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import java.util.concurrent.TimeUnit;</span></span>\n<span class="line"><span>import java.util.concurrent.locks.Lock;</span></span>\n<span class="line"><span>import java.util.concurrent.locks.ReentrantLock;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span> * 资源类</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>class Phone implements Runnable{</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    Lock lock = new ReentrantLock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public void getLock() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t get Lock&quot;);</span></span>\n<span class="line"><span>            setLock();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void setLock() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t set Lock&quot;);</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    @Override</span></span>\n<span class="line"><span>    public void run() {</span></span>\n<span class="line"><span>        getLock();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>public class ReenterLockDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        Phone phone = new Phone();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        /**</span></span>\n<span class="line"><span>         * 因为Phone实现了Runnable接口</span></span>\n<span class="line"><span>         */</span></span>\n<span class="line"><span>        Thread t3 = new Thread(phone, &quot;t3&quot;);</span></span>\n<span class="line"><span>        Thread t4 = new Thread(phone, &quot;t4&quot;);</span></span>\n<span class="line"><span>        t3.start();</span></span>\n<span class="line"><span>        t4.start();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们使用ReentrantLock进行验证，首先资源类实现了Runnable接口，重写Run方法，里面调用get方法，get方法在进入的时候，就加了锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public void getLock() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t get Lock&quot;);</span></span>\n<span class="line"><span>            setLock();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在方法里面，又调用另外一个加了锁的setLock方法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public void setLock() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t set Lock&quot;);</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t3\t get Lock</span></span>\n<span class="line"><span>t3\t set Lock</span></span>\n<span class="line"><span>t4\t get Lock</span></span>\n<span class="line"><span>t4\t set Lock</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>当我们在getLock方法加两把锁会是什么情况呢？</strong> (阿里面试)</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public void getLock() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t get Lock&quot;);</span></span>\n<span class="line"><span>            setLock();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开</p><p><strong>当我们在getLock方法加两把锁，但是只解一把锁会出现什么情况呢？</strong></p><pre><code>public void getLock() {\n    lock.lock();\n    lock.lock();\n    try {\n        System.out.println(Thread.currentThread().getName() + &quot;\\t get Lock&quot;);\n        setLock();\n    } finally {\n        lock.unlock();\n        lock.unlock();\n    }\n}\n</code></pre><p>得到结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t3\t get Lock</span></span>\n<span class="line"><span>t3\t set Lock</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁</p><p><strong>当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public void getLock() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t get Lock&quot;);</span></span>\n<span class="line"><span>            setLock();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候，运行程序会直接报错</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t3\t get Lock</span></span>\n<span class="line"><span>t3\t set Lock</span></span>\n<span class="line"><span>t4\t get Lock</span></span>\n<span class="line"><span>t4\t set Lock</span></span>\n<span class="line"><span>Exception in thread &quot;t3&quot; Exception in thread &quot;t4&quot; java.lang.IllegalMonitorStateException</span></span>\n<span class="line"><span>\tat java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span></span>\n<span class="line"><span>\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span></span>\n<span class="line"><span>\tat java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span></span>\n<span class="line"><span>\tat java.lang.Thread.run(Thread.java:745)</span></span>\n<span class="line"><span>java.lang.IllegalMonitorStateException</span></span>\n<span class="line"><span>\tat java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span></span>\n<span class="line"><span>\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span></span>\n<span class="line"><span>\tat java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span></span>\n<span class="line"><span>\tat java.lang.Thread.run(Thread.java:745)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',34),t={},r=(0,a(66262).A)(t,[["render",function(n,s){const a=(0,e.g2)("font");return(0,e.uX)(),(0,e.CE)("div",null,[i,l,p,(0,e.Lk)("p",null,[(0,e.eW)("也就是说："),(0,e.bF)(a,{color:"red"},{default:(0,e.k6)((()=>[c])),_:1})]),d])}]]),v=JSON.parse('{"path":"/study-notes/shangguigu-second/lock/three.html","title":"可重入锁(又名递归锁) ReentrantLock","lang":"zh-CN","frontmatter":{"title":"可重入锁(又名递归锁) ReentrantLock","date":"2023-03-11T00:00:00.000Z","tags":["锁"],"category":["学习笔记"],"description":"概念 可重入锁就是递归锁 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁 也就是说： ReentrantLock / Synchronized 就是一个典型的可重入锁 代码 可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁 也...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-second/lock/three.html"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"可重入锁(又名递归锁) ReentrantLock"}],["meta",{"property":"og:description","content":"概念 可重入锁就是递归锁 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁 也就是说： ReentrantLock / Synchronized 就是一个典型的可重入锁 代码 可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁 也..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"可重入锁(又名递归锁) ReentrantLock\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]},{"level":2,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":2,"title":"可重入锁验证","slug":"可重入锁验证","link":"#可重入锁验证","children":[{"level":3,"title":"证明Synchronized","slug":"证明synchronized","link":"#证明synchronized","children":[]},{"level":3,"title":"证明ReentrantLock","slug":"证明reentrantlock","link":"#证明reentrantlock","children":[]}]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":4.18,"words":1254},"filePathRelative":"study-notes/shangguigu-second/lock/three.md","localizedDate":"2023年3月11日","excerpt":"<h2>概念</h2>\\n<p>可重入锁就是递归锁</p>\\n<p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p>\\n<p>也就是说：</p>\\n<p><strong>ReentrantLock / Synchronized 就是一个典型的可重入锁</strong></p>\\n<h2>代码</h2>\\n<p>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>public synchronized void method1() {</span></span>\\n<span class=\\"line\\"><span>\\tmethod2();</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>public synchronized void method2() {</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);