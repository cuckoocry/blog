"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[3294],{66262:(a,s)=>{s.A=(a,s)=>{const n=a.__vccOpts||a;for(const[a,e]of s)n[a]=e;return n}},96865:(a,s,n)=>{n.r(s),n.d(s,{comp:()=>t,data:()=>d});var e=n(20641);const i=n.p+"assets/img/image-20200324144802828.4aa3b3a8.png",l=n.p+"assets/img/image-20200324150646260.d42ea76d.png",p=[(0,e.Fv)('<h2 id="经典错误" tabindex="-1"><a class="header-anchor" href="#经典错误"><span>经典错误</span></a></h2><p>JVM中常见的两个错误</p><p>StackoverFlowError ：栈溢出</p><p>OutofMemoryError: java heap space：堆溢出</p><p>除此之外，还有以下的错误</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构"><span>架构</span></a></h2><p>OutOfMemoryError和StackOverflowError是属于<code>Error</code>，不是Exception</p><figure><img src="'+i+'" alt="image-20200324144802828" tabindex="0" loading="lazy"><figcaption>image-20200324144802828</figcaption></figure><h2 id="stackoverflowerror" tabindex="-1"><a class="header-anchor" href="#stackoverflowerror"><span>StackoverFlowError</span></a></h2><p>堆栈溢出，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p><p>栈一般是512K，不断的深度调用，直到栈被撑破</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-24-14:42</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class StackOverflowErrorDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        stackOverflowError();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 栈一般是512K，不断的深度调用，直到栈被撑破</span></span>\n<span class="line"><span>     * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    private static void stackOverflowError() {</span></span>\n<span class="line"><span>        stackOverflowError();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.oom.StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:17)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="outofmemoryerror" tabindex="-1"><a class="header-anchor" href="#outofmemoryerror"><span>OutOfMemoryError</span></a></h2><h3 id="java-heap-space" tabindex="-1"><a class="header-anchor" href="#java-heap-space"><span>java heap space</span></a></h3><p>创建了很多对象，导致堆空间不够存储</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * Java堆内存不足</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-24-14:50</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class JavaHeapSpaceDemo {</span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 堆空间的大小 -Xms10m -Xmx10m</span></span>\n<span class="line"><span>        // 创建一个 80M的字节数组</span></span>\n<span class="line"><span>        byte [] bytes = new byte[80 * 1024 * 1024];</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们创建一个80M的数组，会直接出现Java heap space</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="gc-overhead-limit-exceeded" tabindex="-1"><a class="header-anchor" href="#gc-overhead-limit-exceeded"><span>GC overhead limit exceeded</span></a></h3><p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，超过了98%的时间用来做GC，并且回收了不到2%的堆内存</p><p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p><p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p><figure><img src="'+l+'" alt="image-20200324150646260" tabindex="0" loading="lazy"><figcaption>image-20200324150646260</figcaption></figure><p>代码演示：</p><p>为了更快的达到效果，我们首先需要设置JVM启动参数</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个异常出现的步骤就是，我们不断的像list中插入String对象，直到启动GC回收</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * GC 回收超时</span></span>\n<span class="line"><span> * JVM参数配置: -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-24-15:14</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class GCOverheadLimitDemo {</span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        int i = 0;</span></span>\n<span class="line"><span>        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            while(true) {</span></span>\n<span class="line"><span>                list.add(String.valueOf(++i).intern());</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            System.out.println(&quot;***************i:&quot; + i);</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>            throw e;</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7106K-&gt;7106K(7168K)] 9154K-&gt;9154K(9728K), [Metaspace: 3504K-&gt;3504K(1056768K)], 0.0311093 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] </span></span>\n<span class="line"><span>[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7136K-&gt;667K(7168K)] 9184K-&gt;667K(9728K), [Metaspace: 3540K-&gt;3540K(1056768K)], 0.0058093 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span></span>\n<span class="line"><span>Heap</span></span>\n<span class="line"><span> PSYoungGen      total 2560K, used 114K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span></span>\n<span class="line"><span>  eden space 2048K, 5% used [0x00000000ffd00000,0x00000000ffd1c878,0x00000000fff00000)</span></span>\n<span class="line"><span>  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span></span>\n<span class="line"><span>  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span></span>\n<span class="line"><span> ParOldGen       total 7168K, used 667K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span></span>\n<span class="line"><span>  object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a6ff8,0x00000000ffd00000)</span></span>\n<span class="line"><span> Metaspace       used 3605K, capacity 4540K, committed 4864K, reserved 1056768K</span></span>\n<span class="line"><span>  class space    used 399K, capacity 428K, committed 512K, reserved 1048576K</span></span>\n<span class="line"><span>  </span></span>\n<span class="line"><span> </span></span>\n<span class="line"><span>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span></span>\n<span class="line"><span>\tat java.lang.Integer.toString(Integer.java:403)</span></span>\n<span class="line"><span>\tat java.lang.String.valueOf(String.java:3099)</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.oom.GCOverheadLimitDemo.main(GCOverheadLimitDemo.java:18)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们能够看到 多次Full GC，并没有清理出空间，在多次执行GC操作后，就抛出异常 GC overhead limit</p><h3 id="direct-buffer-memory" tabindex="-1"><a class="header-anchor" href="#direct-buffer-memory"><span>Direct buffer memory</span></a></h3><p>Netty + NIO：这是由于NIO引起的</p><p>写NIO程序的时候经常会使用ByteBuffer来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>ByteBuffer.allocate(capability)：第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢</p><p>ByteBuffer.allocteDirect(capability)：第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存的拷贝，所以速度相对较快</p><p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候怼内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就奔溃了。</p><p>一句话说：本地内存不足，但是堆内存充足的时候，就会出现这个问题</p><p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后我们申请一个6M的空间</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 只设置了5M的物理内存使用，但是却分配 6M的空间</span></span>\n<span class="line"><span>ByteBuffer bb = ByteBuffer.allocateDirect(6 * 1024 * 1024);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候，运行就会出现问题了</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>配置的maxDirectMemory：5.0MB</span></span>\n<span class="line"><span>[GC (System.gc()) [PSYoungGen: 2030K-&gt;488K(2560K)] 2030K-&gt;796K(9728K), 0.0008326 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span>[Full GC (System.gc()) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 308K-&gt;712K(7168K)] 796K-&gt;712K(9728K), [Metaspace: 3512K-&gt;3512K(1056768K)], 0.0052052 secs] [Times: user=0.09 sys=0.00, real=0.00 secs] </span></span>\n<span class="line"><span>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span></span>\n<span class="line"><span>\tat java.nio.Bits.reserveMemory(Bits.java:693)</span></span>\n<span class="line"><span>\tat java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span></span>\n<span class="line"><span>\tat java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.oom.DIrectBufferMemoryDemo.main(DIrectBufferMemoryDemo.java:19)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="unable-to-create-new-native-thread" tabindex="-1"><a class="header-anchor" href="#unable-to-create-new-native-thread"><span>unable to create new native thread</span></a></h3><p>不能够创建更多的新的线程了，也就是说创建线程的上限达到了</p><p>在高并发场景的时候，会应用到</p><p>高并发请求服务器时，经常会出现如下异常<code>java.lang.OutOfMemoryError:unable to create new native thread</code>，准确说该native thread异常与对应的平台有关</p><p>导致原因：</p><ul><li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限</li><li>服务器并不允许你的应用程序创建这么多线程，linux系统默认运行单个进程可以创建的线程为1024个，如果应用创建超过这个数量，就会报 <code>java.lang.OutOfMemoryError:unable to create new native thread</code></li></ul><p>解决方法：</p><ol><li>想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低</li><li>对于有的应用，确实需要创建很多线程，远超过linux系统默认1024个线程限制，可以通过修改linux服务器配置，扩大linux默认限制</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 无法创建更多的线程</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-24-17:02</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class UnableCreateNewThreadDemo {</span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        for (int i = 0; ; i++) {</span></span>\n<span class="line"><span>            System.out.println(&quot;************** i = &quot; + i);</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                try {</span></span>\n<span class="line"><span>                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span></span>\n<span class="line"><span>                } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                    e.printStackTrace();</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候，就会出现下列的错误，线程数大概在 900多个</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to cerate new native thread</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如何查看线程数</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ulimit -u</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="metaspace" tabindex="-1"><a class="header-anchor" href="#metaspace"><span>Metaspace</span></a></h3><p>元空间内存不足，Matespace元空间应用的是本地内存</p><p><code>-XX:MetaspaceSize</code> 的处理化大小为20M</p><h4 id="元空间是什么" tabindex="-1"><a class="header-anchor" href="#元空间是什么"><span>元空间是什么</span></a></h4><p>元空间就是我们的方法区，存放的是类模板，类信息，常量池等</p><p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p><p>永久代（java8后背元空间Metaspace取代了）存放了以下信息：</p><ul><li>虚拟机加载的类信息</li><li>常量池</li><li>静态变量</li><li>即时编译后的代码</li></ul><p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p><h4 id="代码" tabindex="-1"><a class="header-anchor" href="#代码"><span>代码</span></a></h4><p>在模拟异常生成时候，因为初始化的元空间为20M，因此我们使用JVM参数调整元空间的大小，为了更好的效果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 元空间溢出</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-24-17:32</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class MetaspaceOutOfMemoryDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 静态类</span></span>\n<span class="line"><span>    static class OOMTest {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(final String[] args) {</span></span>\n<span class="line"><span>        // 模拟计数多少次以后发生异常</span></span>\n<span class="line"><span>        int i =0;</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            while (true) {</span></span>\n<span class="line"><span>                i++;</span></span>\n<span class="line"><span>                // 使用Spring的动态字节码技术</span></span>\n<span class="line"><span>                Enhancer enhancer = new Enhancer();</span></span>\n<span class="line"><span>                enhancer.setSuperclass(OOMTest.class);</span></span>\n<span class="line"><span>                enhancer.setUseCache(false);</span></span>\n<span class="line"><span>                enhancer.setCallback(new MethodInterceptor() {</span></span>\n<span class="line"><span>                    @Override</span></span>\n<span class="line"><span>                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {</span></span>\n<span class="line"><span>                        return methodProxy.invokeSuper(o, args);</span></span>\n<span class="line"><span>                    }</span></span>\n<span class="line"><span>                });</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            System.out.println(&quot;********多少次后發生了异常:&quot; + i);</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会出现以下错误：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>发生异常的次数: 201</span></span>\n<span class="line"><span>java.lang.OutOfMemoryError:Metaspace</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>',76)],r={},t=(0,n(66262).A)(r,[["render",function(a,s){return(0,e.uX)(),(0,e.CE)("div",null,p)}]]),d=JSON.parse('{"path":"/study-notes/shangguigu-second/JVM/five.html","title":"Java内存溢出OOM","lang":"zh-CN","frontmatter":{"title":"Java内存溢出OOM","date":"2023-03-11T00:00:00.000Z","tags":["OOM"],"category":["JUC"],"description":"经典错误 JVM中常见的两个错误 StackoverFlowError ：栈溢出 OutofMemoryError: java heap space：堆溢出 除此之外，还有以下的错误 java.lang.StackOverflowError java.lang.OutOfMemoryError：java heap space java.lang.Out...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/study-notes/shangguigu-second/JVM/five.html"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"Java内存溢出OOM"}],["meta",{"property":"og:description","content":"经典错误 JVM中常见的两个错误 StackoverFlowError ：栈溢出 OutofMemoryError: java heap space：堆溢出 除此之外，还有以下的错误 java.lang.StackOverflowError java.lang.OutOfMemoryError：java heap space java.lang.Out..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"OOM"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java内存溢出OOM\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"经典错误","slug":"经典错误","link":"#经典错误","children":[]},{"level":2,"title":"架构","slug":"架构","link":"#架构","children":[]},{"level":2,"title":"StackoverFlowError","slug":"stackoverflowerror","link":"#stackoverflowerror","children":[]},{"level":2,"title":"OutOfMemoryError","slug":"outofmemoryerror","link":"#outofmemoryerror","children":[{"level":3,"title":"java heap space","slug":"java-heap-space","link":"#java-heap-space","children":[]},{"level":3,"title":"GC overhead limit exceeded","slug":"gc-overhead-limit-exceeded","link":"#gc-overhead-limit-exceeded","children":[]},{"level":3,"title":"Direct buffer memory","slug":"direct-buffer-memory","link":"#direct-buffer-memory","children":[]},{"level":3,"title":"unable to create new native thread","slug":"unable-to-create-new-native-thread","link":"#unable-to-create-new-native-thread","children":[]},{"level":3,"title":"Metaspace","slug":"metaspace","link":"#metaspace","children":[]}]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":6.69,"words":2006},"filePathRelative":"study-notes/shangguigu-second/JVM/five.md","localizedDate":"2023年3月11日","excerpt":"<h2>经典错误</h2>\\n<p>JVM中常见的两个错误</p>\\n<p>StackoverFlowError ：栈溢出</p>\\n<p>OutofMemoryError: java heap space：堆溢出</p>\\n<p>除此之外，还有以下的错误</p>\\n<ul>\\n<li>java.lang.StackOverflowError</li>\\n<li>java.lang.OutOfMemoryError：java heap space</li>\\n<li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li>\\n<li>java.lang.OutOfMemoryError：Direct buffer memory</li>\\n<li>java.lang.OutOfMemoryError：unable to create new native thread</li>\\n<li>java.lang.OutOfMemoryError：Metaspace</li>\\n</ul>","autoDesc":true}')}}]);