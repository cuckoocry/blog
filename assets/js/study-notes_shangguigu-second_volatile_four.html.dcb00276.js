"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[5149],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},46704:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>r,data:()=>v});var e=a(20641);const i=a.p+"assets/img/image-20200310164513408.67fac684.png",l=a.p+"assets/img/image-20200310164720940.00128843.png",p=a.p+"assets/img/image-20200310164946940.c51b5d0f.png",t=a.p+"assets/img/image-20200310165703190.0c235b67.png",c=[(0,e.Fv)('<h2 id="单例模式dcl代码" tabindex="-1"><a class="header-anchor" href="#单例模式dcl代码"><span>单例模式DCL代码</span></a></h2><p>首先回顾一下，单线程下的单例模式代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * SingletonDemo（单例模式）</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-10-16:40</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class SingletonDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private static SingletonDemo instance = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private SingletonDemo () {</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t 我是构造方法SingletonDemo&quot;);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static SingletonDemo getInstance() {</span></span>\n<span class="line"><span>        if(instance == null) {</span></span>\n<span class="line"><span>            instance = new SingletonDemo();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        return instance;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        // 这里的 == 是比较内存地址</span></span>\n<span class="line"><span>        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\n<span class="line"><span>        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\n<span class="line"><span>        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\n<span class="line"><span>        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后输出的结果</p><figure><img src="'+i+'" alt="image-20200310164513408" tabindex="0" loading="lazy"><figcaption>image-20200310164513408</figcaption></figure><p>但是在多线程的环境下，我们的单例模式是否还是同一个对象了</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * SingletonDemo（单例模式）</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-10-16:40</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class SingletonDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private static SingletonDemo instance = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private SingletonDemo () {</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t 我是构造方法SingletonDemo&quot;);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static SingletonDemo getInstance() {</span></span>\n<span class="line"><span>        if(instance == null) {</span></span>\n<span class="line"><span>            instance = new SingletonDemo();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        return instance;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 10; i++) {</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                SingletonDemo.getInstance();</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从下面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面几个线程都进行了创建，那么在多线程环境下，单例模式如何保证呢？</p><figure><img src="'+l+'" alt="image-20200310164720940" tabindex="0" loading="lazy"><figcaption>image-20200310164720940</figcaption></figure><h3 id="解决方法1" tabindex="-1"><a class="header-anchor" href="#解决方法1"><span>解决方法1</span></a></h3><p>引入synchronized关键字</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public synchronized static SingletonDemo getInstance() {</span></span>\n<span class="line"><span>        if(instance == null) {</span></span>\n<span class="line"><span>            instance = new SingletonDemo();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        return instance;</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p><figure><img src="'+p+'" alt="image-20200310164946940" tabindex="0" loading="lazy"><figcaption>image-20200310164946940</figcaption></figure><p>我们能够发现，通过引入Synchronized关键字，能够解决高并发环境下的单例模式问题</p><p>但是synchronized属于重量级的同步机制，它只允许一个线程同时访问获取实例的方法，但是为了保证数据一致性，而减低了并发性，因此采用的比较少</p><h3 id="解决方法2" tabindex="-1"><a class="header-anchor" href="#解决方法2"><span>解决方法2</span></a></h3><p>通过引入DCL Double Check Lock 双端检锁机制</p><p>就是在进来和出去的时候，进行检测</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public static SingletonDemo getInstance() {</span></span>\n<span class="line"><span>        if(instance == null) {</span></span>\n<span class="line"><span>            // 同步代码段的时候，进行检测</span></span>\n<span class="line"><span>            synchronized (SingletonDemo.class) {</span></span>\n<span class="line"><span>                if(instance == null) {</span></span>\n<span class="line"><span>                    instance = new SingletonDemo();</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        return instance;</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后输出的结果为：</p><figure><img src="'+t+'" alt="image-20200310165703190" tabindex="0" loading="lazy"><figcaption>image-20200310165703190</figcaption></figure><p>从输出结果来看，确实能够保证单例模式的正确性，但是上面的方法还是存在问题的</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排</p><p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象可能没有完成实例化。因为 instance = new SingletonDemo()；可以分为以下三步进行完成：</p><ul><li>memory = allocate(); // 1、分配对象内存空间</li><li>instance(memory); // 2、初始化对象</li><li>instance = memory; // 3、设置instance指向刚刚分配的内存地址，此时instance != null</li></ul><p>但是我们通过上面的三个步骤，能够发现，步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</p><ul><li>memory = allocate(); // 1、分配对象内存空间</li><li>instance = memory; // 3、设置instance指向刚刚分配的内存地址，此时instance != null，但是对象还没有初始化完成</li><li>instance(memory); // 2、初始化对象</li></ul><p>这样就会造成什么问题呢？</p><p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会重新在创建一个instance实例</p><p><code>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</code></p><p>所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，这就造成了线程安全的问题</p><p>所以需要引入volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>private static volatile SingletonDemo instance = null;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="最终代码" tabindex="-1"><a class="header-anchor" href="#最终代码"><span>最终代码</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * SingletonDemo（单例模式）</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-10-16:40</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class SingletonDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private static volatile SingletonDemo instance = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private SingletonDemo () {</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t 我是构造方法SingletonDemo&quot;);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static SingletonDemo getInstance() {</span></span>\n<span class="line"><span>        if(instance == null) {</span></span>\n<span class="line"><span>            // a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span></span>\n<span class="line"><span>            synchronized (SingletonDemo.class) //b</span></span>\n<span class="line"><span>            { </span></span>\n<span class="line"><span>           //c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span></span>\n<span class="line"><span>                if(instance == null) { </span></span>\n<span class="line"><span>                \t// d 此时才开始初始化</span></span>\n<span class="line"><span>                    instance = new SingletonDemo();</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        return instance;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>//        // 这里的 == 是比较内存地址</span></span>\n<span class="line"><span>//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\n<span class="line"><span>//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\n<span class="line"><span>//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\n<span class="line"><span>//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 10; i++) {</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                SingletonDemo.getInstance();</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',36)],d={},r=(0,a(66262).A)(d,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,c)}]]),v=JSON.parse('{"path":"/study-notes/shangguigu-second/volatile/four.html","title":"Volatile的应用","lang":"zh-CN","frontmatter":{"title":"Volatile的应用","date":"2023-03-11T00:00:00.000Z","tags":["JUC","Volatile"],"category":["JUC"],"order":4,"description":"单例模式DCL代码 首先回顾一下，单线程下的单例模式代码 最后输出的结果 image-20200310164513408image-20200310164513408 但是在多线程的环境下，我们的单例模式是否还是同一个对象了 从下面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/study-notes/shangguigu-second/volatile/four.html"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"Volatile的应用"}],["meta",{"property":"og:description","content":"单例模式DCL代码 首先回顾一下，单线程下的单例模式代码 最后输出的结果 image-20200310164513408image-20200310164513408 但是在多线程的环境下，我们的单例模式是否还是同一个对象了 从下面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:tag","content":"Volatile"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Volatile的应用\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"单例模式DCL代码","slug":"单例模式dcl代码","link":"#单例模式dcl代码","children":[{"level":3,"title":"解决方法1","slug":"解决方法1","link":"#解决方法1","children":[]},{"level":3,"title":"解决方法2","slug":"解决方法2","link":"#解决方法2","children":[]},{"level":3,"title":"最终代码","slug":"最终代码","link":"#最终代码","children":[]}]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":4,"words":1201},"filePathRelative":"study-notes/shangguigu-second/volatile/four.md","localizedDate":"2023年3月11日","excerpt":"<h2>单例模式DCL代码</h2>\\n<p>首先回顾一下，单线程下的单例模式代码</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>/**</span></span>\\n<span class=\\"line\\"><span> * SingletonDemo（单例模式）</span></span>\\n<span class=\\"line\\"><span> *</span></span>\\n<span class=\\"line\\"><span> * @author: 阿飞</span></span>\\n<span class=\\"line\\"><span> * @create: 2020-03-10-16:40</span></span>\\n<span class=\\"line\\"><span> */</span></span>\\n<span class=\\"line\\"><span>public class SingletonDemo {</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    private static SingletonDemo instance = null;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    private SingletonDemo () {</span></span>\\n<span class=\\"line\\"><span>        System.out.println(Thread.currentThread().getName() + \\"\\\\t 我是构造方法SingletonDemo\\");</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    public static SingletonDemo getInstance() {</span></span>\\n<span class=\\"line\\"><span>        if(instance == null) {</span></span>\\n<span class=\\"line\\"><span>            instance = new SingletonDemo();</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>        return instance;</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    public static void main(String[] args) {</span></span>\\n<span class=\\"line\\"><span>        // 这里的 == 是比较内存地址</span></span>\\n<span class=\\"line\\"><span>        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\\n<span class=\\"line\\"><span>        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\\n<span class=\\"line\\"><span>        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\\n<span class=\\"line\\"><span>        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);