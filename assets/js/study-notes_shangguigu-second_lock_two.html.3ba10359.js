"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[9660],{66262:(e,n)=>{n.A=(e,n)=>{const a=e.__vccOpts||e;for(const[e,t]of n)a[e]=t;return a}},89980:(e,n,a)=>{a.r(n),a.d(n,{comp:()=>r,data:()=>o});var t=a(20641);const s=(0,t.Fv)('<h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><h3 id="公平锁" tabindex="-1"><a class="header-anchor" href="#公平锁"><span>公平锁</span></a></h3><p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p><h3 id="非公平锁" tabindex="-1"><a class="header-anchor" href="#非公平锁"><span>非公平锁</span></a></h3><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p><h2 id="如何创建" tabindex="-1"><a class="header-anchor" href="#如何创建"><span>如何创建</span></a></h2><p>并发包中ReentrantLock的创建可以指定析构函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span>* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span></span>\n<span class="line"><span>*/</span></span>\n<span class="line"><span>Lock lock = new ReentrantLock(true);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="两者区别" tabindex="-1"><a class="header-anchor" href="#两者区别"><span>两者区别</span></a></h2><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后安装FIFO的规则从队列中取到自己</p><p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p><h2 id="题外话" tabindex="-1"><a class="header-anchor" href="#题外话"><span>题外话</span></a></h2>',12),i=(0,t.Lk)("code",null,"对于synchronized而言，也是一种非公平锁",-1),l={},r=(0,a(66262).A)(l,[["render",function(e,n){const a=(0,t.g2)("font");return(0,t.uX)(),(0,t.CE)("div",null,[s,(0,t.Lk)("p",null,[(0,t.eW)("Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，"),(0,t.bF)(a,{color:"red"},{default:(0,t.k6)((()=>[i])),_:1})])])}]]),o=JSON.parse('{"path":"/study-notes/shangguigu-second/lock/two.html","title":"Java锁之公平锁和非公平锁","lang":"zh-CN","frontmatter":{"title":"Java锁之公平锁和非公平锁","date":"2023-03-11T00:00:00.000Z","tags":["锁"],"category":["学习笔记"],"dir":{"order":2},"description":"概念 公平锁 是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列 非公平锁 是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁） 如何创建 并发包中ReentrantLock的创建可以...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-second/lock/two.html"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"Java锁之公平锁和非公平锁"}],["meta",{"property":"og:description","content":"概念 公平锁 是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列 非公平锁 是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁） 如何创建 并发包中ReentrantLock的创建可以..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java锁之公平锁和非公平锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[{"level":3,"title":"公平锁","slug":"公平锁","link":"#公平锁","children":[]},{"level":3,"title":"非公平锁","slug":"非公平锁","link":"#非公平锁","children":[]}]},{"level":2,"title":"如何创建","slug":"如何创建","link":"#如何创建","children":[]},{"level":2,"title":"两者区别","slug":"两者区别","link":"#两者区别","children":[]},{"level":2,"title":"题外话","slug":"题外话","link":"#题外话","children":[]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":1.44,"words":431},"filePathRelative":"study-notes/shangguigu-second/lock/two.md","localizedDate":"2023年3月11日","excerpt":"<h2>概念</h2>\\n<h3>公平锁</h3>\\n<p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p>\\n<h3>非公平锁</h3>\\n<p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p>\\n<h2>如何创建</h2>\\n<p>并发包中ReentrantLock的创建可以指定析构函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>/**</span></span>\\n<span class=\\"line\\"><span>* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span></span>\\n<span class=\\"line\\"><span>*/</span></span>\\n<span class=\\"line\\"><span>Lock lock = new ReentrantLock(true);</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);