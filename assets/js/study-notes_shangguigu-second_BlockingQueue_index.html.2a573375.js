"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[3629],{6262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}},517:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>d,data:()=>r});var i=a(641);const e=a.p+"assets/img/image-20200316152120272.0ab96001.png",l=a.p+"assets/img/image-20200316154442756.12d44207.png",p=[(0,i.Fv)('<h3 id="队列" tabindex="-1"><a class="header-anchor" href="#队列"><span>队列</span></a></h3><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p><h3 id="阻塞队列" tabindex="-1"><a class="header-anchor" href="#阻塞队列"><span>阻塞队列</span></a></h3><p>BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p><figure><img src="'+e+'" alt="image-20200316152120272" tabindex="0" loading="lazy"><figcaption>image-20200316152120272</figcaption></figure><p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p><ul><li><code>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</code></li><li><code>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</code></li></ul><p>也就是说: 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素。</p><p>同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增。</p><h2 id="为什么要用" tabindex="-1"><a class="header-anchor" href="#为什么要用"><span>为什么要用？</span></a></h2><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p><p>在多线程领域：所谓的阻塞，在某些清空下会<code>挂起</code>线程（即阻塞），一旦条件满足，被挂起的线程又会自<code>动唤醒</code>。</p><h3 id="为什么需要-blockingqueue" tabindex="-1"><a class="header-anchor" href="#为什么需要-blockingqueue"><span>为什么需要 BlockingQueue</span></a></h3><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了。</p><p>在concurrent包发布以前，在多线程环境下，<code>我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全</code>，而这会给我们的程序带来不小的复杂度。</p><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构"><span>架构</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 你用过List集合类</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// ArrayList集合类熟悉么？</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 还用过 CopyOnWriteList  和 BlockingQueue</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>BlockingQueue阻塞队列是属于一个<code>接口</code>，底下有七个实现类</p><ul><li><code>ArrayBlockQueue：由数组结构组成的有界阻塞队列</code></li><li><code>LinkedBlockingQueue：由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列</code><ul><li>有界，但是界限非常大，相当于无界，可以当成无界</li></ul></li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li><li><code>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列</code><ul><li>生产一个，消费一个，不存储元素，不消费不生产</li></ul></li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ul><p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p><h2 id="blockingqueue核心方法" tabindex="-1"><a class="header-anchor" href="#blockingqueue核心方法"><span>BlockingQueue核心方法</span></a></h2><figure><img src="'+l+'" alt="image-20200316154442756" tabindex="0" loading="lazy"><figcaption>image-20200316154442756</figcaption></figure><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full 当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException</th></tr></thead><tbody><tr><td>特殊性</td><td>插入方法，成功true，失败false 移除方法：成功返回出队列元素，队列没有就返回空</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出， 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h3 id="抛出异常组" tabindex="-1"><a class="header-anchor" href="#抛出异常组"><span>抛出异常组</span></a></h3><p>但执行add方法，向已经满的ArrayBlockingQueue中添加元素时候，会抛出异常</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 阻塞队列，需要填入默认值</span></span>\n<span class="line"><span>BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>System.out.println(blockingQueue.add(&quot;a&quot;));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.add(&quot;b&quot;));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.add(&quot;c&quot;));</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>System.out.println(blockingQueue.add(&quot;XXX&quot;));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行后：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>true</span></span>\n<span class="line"><span>true</span></span>\n<span class="line"><span>true</span></span>\n<span class="line"><span>Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span></span>\n<span class="line"><span>\tat java.util.AbstractQueue.add(AbstractQueue.java:98)</span></span>\n<span class="line"><span>\tat java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:25)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时如果我们多取出元素的时候，也会抛出异常，我们假设只存储了3个值，但是取的时候，取了四次</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 阻塞队列，需要填入默认值</span></span>\n<span class="line"><span>BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span></span>\n<span class="line"><span>System.out.println(blockingQueue.add(&quot;a&quot;));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.add(&quot;b&quot;));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.add(&quot;c&quot;));</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>System.out.println(blockingQueue.remove());</span></span>\n<span class="line"><span>System.out.println(blockingQueue.remove());</span></span>\n<span class="line"><span>System.out.println(blockingQueue.remove());</span></span>\n<span class="line"><span>System.out.println(blockingQueue.remove());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么出现异常</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>true</span></span>\n<span class="line"><span>true</span></span>\n<span class="line"><span>true</span></span>\n<span class="line"><span>a</span></span>\n<span class="line"><span>b</span></span>\n<span class="line"><span>c</span></span>\n<span class="line"><span>Exception in thread &quot;main&quot; java.util.NoSuchElementException</span></span>\n<span class="line"><span>\tat java.util.AbstractQueue.remove(AbstractQueue.java:117)</span></span>\n<span class="line"><span>\tat com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:30)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="布尔类型组" tabindex="-1"><a class="header-anchor" href="#布尔类型组"><span>布尔类型组</span></a></h3><p>我们使用 offer的方法，添加元素时候，如果阻塞队列满了后，会返回false，否者返回true</p><p>同时在取的时候，如果队列已空，那么会返回null</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>BlockingQueue blockingQueue = new ArrayBlockingQueue(3);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>System.out.println(blockingQueue.offer(&quot;a&quot;));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.offer(&quot;b&quot;));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.offer(&quot;c&quot;));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.offer(&quot;d&quot;));</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>System.out.println(blockingQueue.poll());</span></span>\n<span class="line"><span>System.out.println(blockingQueue.poll());</span></span>\n<span class="line"><span>System.out.println(blockingQueue.poll());</span></span>\n<span class="line"><span>System.out.println(blockingQueue.poll());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>true</span></span>\n<span class="line"><span>true</span></span>\n<span class="line"><span>true</span></span>\n<span class="line"><span>false</span></span>\n<span class="line"><span>a</span></span>\n<span class="line"><span>b</span></span>\n<span class="line"><span>c</span></span>\n<span class="line"><span>null</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="阻塞队列组" tabindex="-1"><a class="header-anchor" href="#阻塞队列组"><span>阻塞队列组</span></a></h3><p>我们使用 put的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直阻塞，直到队列元素减少，会被清空，才会唤醒</p><p>一般在消息中间件，比如RabbitMQ中会使用到，因为需要保证消息百分百不丢失，因此只有让它阻塞</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span></span>\n<span class="line"><span>blockingQueue.put(&quot;a&quot;);</span></span>\n<span class="line"><span>blockingQueue.put(&quot;b&quot;);</span></span>\n<span class="line"><span>blockingQueue.put(&quot;c&quot;);</span></span>\n<span class="line"><span>System.out.println(&quot;================&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>blockingQueue.take();</span></span>\n<span class="line"><span>blockingQueue.take();</span></span>\n<span class="line"><span>blockingQueue.take();</span></span>\n<span class="line"><span>blockingQueue.take();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时使用take取消息的时候，如果内容不存在的时候，也会被阻塞</p><h3 id="不见不散组" tabindex="-1"><a class="header-anchor" href="#不见不散组"><span>不见不散组</span></a></h3><p>offer( ) ， poll 加时间</p><p>使用offer插入的时候，需要指定时间，如果2秒还没有插入，那么就放弃插入</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span></span>\n<span class="line"><span>System.out.println(blockingQueue.offer(&quot;a&quot;, 2L, TimeUnit.SECONDS));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.offer(&quot;b&quot;, 2L, TimeUnit.SECONDS));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.offer(&quot;c&quot;, 2L, TimeUnit.SECONDS));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.offer(&quot;d&quot;, 2L, TimeUnit.SECONDS));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时取的时候也进行判断</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span></span>\n<span class="line"><span>System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果2秒内取不出来，那么就返回null</p><h2 id="synchronousqueue" tabindex="-1"><a class="header-anchor" href="#synchronousqueue"><span>SynchronousQueue</span></a></h2><p>SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储的BlockingQueue，每一个put操作必须等待一个take操作，否者不能继续添加元素</p><p>下面我们测试SynchronousQueue添加元素的过程</p><p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p><p>生产的线程分别put了 A、B、C这三个字段</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>new Thread(() -&gt; {</span></span>\n<span class="line"><span>    try {       </span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t put A &quot;);</span></span>\n<span class="line"><span>        blockingQueue.put(&quot;A&quot;);</span></span>\n<span class="line"><span>       </span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t put B &quot;);</span></span>\n<span class="line"><span>        blockingQueue.put(&quot;B&quot;);        </span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t put C &quot;);</span></span>\n<span class="line"><span>        blockingQueue.put(&quot;C&quot;);        </span></span>\n<span class="line"><span>        </span></span>\n<span class="line"><span>    } catch (InterruptedException e) {</span></span>\n<span class="line"><span>        e.printStackTrace();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}, &quot;t1&quot;).start();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消费线程使用take，消费阻塞队列中的内容，并且每次消费前，都等待5秒</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>                try {</span></span>\n<span class="line"><span>                    TimeUnit.SECONDS.sleep(5);</span></span>\n<span class="line"><span>                } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                    e.printStackTrace();</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>                blockingQueue.take();</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t take A &quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>                try {</span></span>\n<span class="line"><span>                    TimeUnit.SECONDS.sleep(5);</span></span>\n<span class="line"><span>                } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                    e.printStackTrace();</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>                blockingQueue.take();</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t take B &quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>                try {</span></span>\n<span class="line"><span>                    TimeUnit.SECONDS.sleep(5);</span></span>\n<span class="line"><span>                } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                    e.printStackTrace();</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>                blockingQueue.take();</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t take C &quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;t2&quot;).start();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后结果输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t1\t put A </span></span>\n<span class="line"><span>t2\t take A </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>5秒后...</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>t1\t put B </span></span>\n<span class="line"><span>t2\t take B </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>5秒后...</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>t1\t put C </span></span>\n<span class="line"><span>t2\t take C</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们从最后的运行结果可以看出，每次t1线程向队列中添加阻塞队列添加元素后，t1输入线程就会等待 t2消费线程，t2消费后，t2处于挂起状态，等待t1在存入，从而周而复始，形成 一存一取的状态</p><h2 id="阻塞队列的用处" tabindex="-1"><a class="header-anchor" href="#阻塞队列的用处"><span>阻塞队列的用处</span></a></h2><h3 id="生产者消费者模式" tabindex="-1"><a class="header-anchor" href="#生产者消费者模式"><span>生产者消费者模式</span></a></h3><p>一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</p><p>关于多线程的操作，我们需要记住下面几句</p><ul><li>线程 操作 资源类</li><li>判断 干活 通知</li><li>防止虚假唤醒机制</li></ul><p>我们下面实现一个简单的生产者消费者模式，首先有资源类ShareData</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 资源类 （线程操作资源类）</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>class ShareData {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private int number = 0;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private Lock lock = new ReentrantLock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private Condition condition = lock.newCondition();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void increment() throws Exception{</span></span>\n<span class="line"><span>        // 同步代码块，加锁</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 判断</span></span>\n<span class="line"><span>            while(number != 0) {</span></span>\n<span class="line"><span>                // 等待不能生产</span></span>\n<span class="line"><span>                condition.await();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 干活</span></span>\n<span class="line"><span>            number++;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t &quot; + number);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 通知 唤醒</span></span>\n<span class="line"><span>            condition.signalAll();</span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void decrement() throws Exception{</span></span>\n<span class="line"><span>        // 同步代码块，加锁</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 判断</span></span>\n<span class="line"><span>            while(number == 0) {</span></span>\n<span class="line"><span>                // 等待不能消费</span></span>\n<span class="line"><span>                condition.await();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 干活</span></span>\n<span class="line"><span>            number--;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t &quot; + number);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 通知 唤醒</span></span>\n<span class="line"><span>            condition.signalAll();</span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>里面有一个number变量，同时提供了increment 和 decrement的方法，分别让number 加1和减1</p><p>但是我们在进行判断的时候，为了防止出现虚假唤醒机制，不能使用if来进行判断，而应该使用while</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 判断</span></span>\n<span class="line"><span>while(number != 0) {</span></span>\n<span class="line"><span>    // 等待不能生产</span></span>\n<span class="line"><span>    condition.await();</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不能使用 if判断</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 判断</span></span>\n<span class="line"><span>if(number != 0) {</span></span>\n<span class="line"><span>    // 等待不能生产</span></span>\n<span class="line"><span>    condition.await();</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 生产者消费者 传统版</span></span>\n<span class="line"><span> * 题目：一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2023-03-04</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span> * 线程 操作 资源类</span></span>\n<span class="line"><span> * 判断 干活 通知</span></span>\n<span class="line"><span> * 防止虚假唤醒机制</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span> * 资源类</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>class ShareData {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private int number = 0;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private Lock lock = new ReentrantLock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private Condition condition = lock.newCondition();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void increment() throws Exception{</span></span>\n<span class="line"><span>        // 同步代码块，加锁</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 判断</span></span>\n<span class="line"><span>            while(number != 0) {</span></span>\n<span class="line"><span>                // 等待不能生产</span></span>\n<span class="line"><span>                condition.await();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 干活</span></span>\n<span class="line"><span>            number++;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t &quot; + number);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 通知 唤醒</span></span>\n<span class="line"><span>            condition.signalAll();</span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void decrement() throws Exception{</span></span>\n<span class="line"><span>        // 同步代码块，加锁</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 判断</span></span>\n<span class="line"><span>            while(number == 0) {</span></span>\n<span class="line"><span>                // 等待不能消费</span></span>\n<span class="line"><span>                condition.await();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 干活</span></span>\n<span class="line"><span>            number--;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t &quot; + number);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 通知 唤醒</span></span>\n<span class="line"><span>            condition.signalAll();</span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>public class ProdConsumerTraditionDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 高内聚，低耦合    内聚指的是，一个空调，自身带有调节温度高低的方法</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        ShareData shareData = new ShareData();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // t1线程，生产</span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            for (int i = 0; i &lt; 5; i++) {</span></span>\n<span class="line"><span>                try {</span></span>\n<span class="line"><span>                    shareData.increment();</span></span>\n<span class="line"><span>                } catch (Exception e) {</span></span>\n<span class="line"><span>                    e.printStackTrace();</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;t1&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // t2线程，消费</span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            for (int i = 0; i &lt; 5; i++) {</span></span>\n<span class="line"><span>                try {</span></span>\n<span class="line"><span>                    shareData.decrement();</span></span>\n<span class="line"><span>                } catch (Exception e) {</span></span>\n<span class="line"><span>                    e.printStackTrace();</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;t2&quot;).start();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后运行成功后，我们一个进行生产，一个进行消费</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t1\t 1</span></span>\n<span class="line"><span>t2\t 0</span></span>\n<span class="line"><span>t1\t 1</span></span>\n<span class="line"><span>t2\t 0</span></span>\n<span class="line"><span>t1\t 1</span></span>\n<span class="line"><span>t2\t 0</span></span>\n<span class="line"><span>t1\t 1</span></span>\n<span class="line"><span>t2\t 0</span></span>\n<span class="line"><span>t1\t 1</span></span>\n<span class="line"><span>t2\t 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="生成者和消费者3-0" tabindex="-1"><a class="header-anchor" href="#生成者和消费者3-0"><span>生成者和消费者3.0</span></a></h2><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度</p><p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 生产者消费者  阻塞队列版</span></span>\n<span class="line"><span> * 使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2023-03-17-11:13</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>class MyResource {</span></span>\n<span class="line"><span>    // 默认开启，进行生产消费</span></span>\n<span class="line"><span>    // 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改</span></span>\n<span class="line"><span>    private volatile boolean FLAG = true;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 使用原子包装类，而不用number++</span></span>\n<span class="line"><span>    private AtomicInteger atomicInteger = new AtomicInteger();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue</span></span>\n<span class="line"><span>    BlockingQueue&lt;String&gt; blockingQueue = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 而应该采用依赖注入里面的，构造注入方法传入</span></span>\n<span class="line"><span>    public MyResource(BlockingQueue&lt;String&gt; blockingQueue) {</span></span>\n<span class="line"><span>        this.blockingQueue = blockingQueue;</span></span>\n<span class="line"><span>        // 查询出传入的class是什么</span></span>\n<span class="line"><span>        System.out.println(blockingQueue.getClass().getName());</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 生产</span></span>\n<span class="line"><span>     * @throws Exception</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public void myProd() throws Exception{</span></span>\n<span class="line"><span>        String data = null;</span></span>\n<span class="line"><span>        boolean retValue;</span></span>\n<span class="line"><span>        // 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span></span>\n<span class="line"><span>        // 当FLAG为true的时候，开始生产</span></span>\n<span class="line"><span>        while(FLAG) {</span></span>\n<span class="line"><span>            data = atomicInteger.incrementAndGet() + &quot;&quot;;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 2秒存入1个data</span></span>\n<span class="line"><span>            retValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);</span></span>\n<span class="line"><span>            if(retValue) {</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t 插入队列:&quot; + data  + &quot;成功&quot; );</span></span>\n<span class="line"><span>            } else {</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t 插入队列:&quot; + data  + &quot;失败&quot; );</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                TimeUnit.SECONDS.sleep(1);</span></span>\n<span class="line"><span>            } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t 停止生产，表示FLAG=false，生产介绍&quot;);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 消费</span></span>\n<span class="line"><span>     * @throws Exception</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public void myConsumer() throws Exception{</span></span>\n<span class="line"><span>        String retValue;</span></span>\n<span class="line"><span>        // 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span></span>\n<span class="line"><span>        // 当FLAG为true的时候，开始生产</span></span>\n<span class="line"><span>        while(FLAG) {</span></span>\n<span class="line"><span>            // 2秒存入1个data</span></span>\n<span class="line"><span>            retValue = blockingQueue.poll(2L, TimeUnit.SECONDS);</span></span>\n<span class="line"><span>            if(retValue != null &amp;&amp; retValue != &quot;&quot;) {</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t 消费队列:&quot; + retValue  + &quot;成功&quot; );</span></span>\n<span class="line"><span>            } else {</span></span>\n<span class="line"><span>                FLAG = false;</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t 消费失败，队列中已为空，退出&quot; );</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>                // 退出消费队列</span></span>\n<span class="line"><span>                return;</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 停止生产的判断</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public void stop() {</span></span>\n<span class="line"><span>        this.FLAG = false;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>public class ProdConsumerBlockingQueueDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        // 传入具体的实现类， ArrayBlockingQueue</span></span>\n<span class="line"><span>        MyResource myResource = new MyResource(new ArrayBlockingQueue&lt;String&gt;(10));</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t 生产线程启动&quot;);</span></span>\n<span class="line"><span>            System.out.println(&quot;&quot;);</span></span>\n<span class="line"><span>            System.out.println(&quot;&quot;);</span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                myResource.myProd();</span></span>\n<span class="line"><span>                System.out.println(&quot;&quot;);</span></span>\n<span class="line"><span>                System.out.println(&quot;&quot;);</span></span>\n<span class="line"><span>            } catch (Exception e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;prod&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t 消费线程启动&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                myResource.myConsumer();</span></span>\n<span class="line"><span>            } catch (Exception e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;consumer&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 5秒后，停止生产和消费</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            TimeUnit.SECONDS.sleep(5);</span></span>\n<span class="line"><span>        } catch (InterruptedException e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        System.out.println(&quot;&quot;);</span></span>\n<span class="line"><span>        System.out.println(&quot;&quot;);</span></span>\n<span class="line"><span>        System.out.println(&quot;5秒中后，生产和消费线程停止，线程结束&quot;);</span></span>\n<span class="line"><span>        myResource.stop();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后运行结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>java.util.concurrent.ArrayBlockingQueue</span></span>\n<span class="line"><span>prod\t 生产线程启动</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>consumer\t 消费线程启动</span></span>\n<span class="line"><span>prod\t 插入队列:1成功</span></span>\n<span class="line"><span>consumer\t 消费队列:1成功</span></span>\n<span class="line"><span>prod\t 插入队列:2成功</span></span>\n<span class="line"><span>consumer\t 消费队列:2成功</span></span>\n<span class="line"><span>prod\t 插入队列:3成功</span></span>\n<span class="line"><span>consumer\t 消费队列:3成功</span></span>\n<span class="line"><span>prod\t 插入队列:4成功</span></span>\n<span class="line"><span>consumer\t 消费队列:4成功</span></span>\n<span class="line"><span>prod\t 插入队列:5成功</span></span>\n<span class="line"><span>consumer\t 消费队列:5成功</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>5秒中后，生产和消费线程停止，线程结束</span></span>\n<span class="line"><span>prod\t 停止生产，表示FLAG=false，生产介绍</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',83)],c={},d=(0,a(6262).A)(c,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,p)}]]),r=JSON.parse('{"path":"/study-notes/shangguigu-second/BlockingQueue/","title":"7、阻塞队列","lang":"zh-CN","frontmatter":{"title":"7、阻塞队列","date":"2023-03-11T00:00:00.000Z","tags":["BlockingQueue"],"category":["JUC"],"description":"队列 队列就可以想成是一个数组，从一头进入，一头出去，排队买饭 阻塞队列 BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示： image-20200316152120272image-20200316152120272 线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素 当阻塞队...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-second/BlockingQueue/"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"7、阻塞队列"}],["meta",{"property":"og:description","content":"队列 队列就可以想成是一个数组，从一头进入，一头出去，排队买饭 阻塞队列 BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示： image-20200316152120272image-20200316152120272 线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素 当阻塞队..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"BlockingQueue"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"7、阻塞队列\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"队列","slug":"队列","link":"#队列","children":[]},{"level":3,"title":"阻塞队列","slug":"阻塞队列","link":"#阻塞队列","children":[]},{"level":2,"title":"为什么要用？","slug":"为什么要用","link":"#为什么要用","children":[{"level":3,"title":"为什么需要 BlockingQueue","slug":"为什么需要-blockingqueue","link":"#为什么需要-blockingqueue","children":[]}]},{"level":2,"title":"架构","slug":"架构","link":"#架构","children":[]},{"level":2,"title":"BlockingQueue核心方法","slug":"blockingqueue核心方法","link":"#blockingqueue核心方法","children":[{"level":3,"title":"抛出异常组","slug":"抛出异常组","link":"#抛出异常组","children":[]},{"level":3,"title":"布尔类型组","slug":"布尔类型组","link":"#布尔类型组","children":[]},{"level":3,"title":"阻塞队列组","slug":"阻塞队列组","link":"#阻塞队列组","children":[]},{"level":3,"title":"不见不散组","slug":"不见不散组","link":"#不见不散组","children":[]}]},{"level":2,"title":"SynchronousQueue","slug":"synchronousqueue","link":"#synchronousqueue","children":[]},{"level":2,"title":"阻塞队列的用处","slug":"阻塞队列的用处","link":"#阻塞队列的用处","children":[{"level":3,"title":"生产者消费者模式","slug":"生产者消费者模式","link":"#生产者消费者模式","children":[]}]},{"level":2,"title":"生成者和消费者3.0","slug":"生成者和消费者3-0","link":"#生成者和消费者3-0","children":[]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":10.69,"words":3206},"filePathRelative":"study-notes/shangguigu-second/BlockingQueue/README.md","localizedDate":"2023年3月11日","excerpt":"<h3>队列</h3>\\n<p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p>\\n<h3>阻塞队列</h3>\\n<p>BlockingQueue   阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p>\\n<figure><figcaption>image-20200316152120272</figcaption></figure>\\n<p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p>\\n<ul>\\n<li><code>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</code></li>\\n<li><code>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</code></li>\\n</ul>","autoDesc":true}')}}]);