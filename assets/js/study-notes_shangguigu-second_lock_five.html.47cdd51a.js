"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[6432],{66262:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,a]of t)i[e]=a;return i}},76681:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>o,data:()=>r});var a=i(20641);const n=[(0,a.Fv)('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念：</p><ul><li>Java内存模型</li><li>并发编程有序性问题</li><li>指令重排</li><li>synchronized锁</li><li>可重入锁</li><li>排它锁</li><li>as-if-serial语义</li><li>单线程&amp;多线程</li></ul><h2 id="标准解答" tabindex="-1"><a class="header-anchor" href="#标准解答"><span>标准解答</span></a></h2><p>为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p><blockquote><p>先解释什么是有序性问题，也知道是什么原因导致的有序性问题</p></blockquote><p>我们也知道，最好的解决有序性问题的办法，就是禁止处理器优化和指令重排，就像volatile中使用内存屏障一样。</p><blockquote><p>表明你知道啥是指令重排，也知道他的实现原理</p></blockquote><p>但是，虽然很多硬件都会为了优化做一些重排，但是在Java中，不管怎么排序，都不能影响单线程程序的执行结果。这就是as-if-serial语义，所有硬件优化的前提都是必须遵守as-if-serial语义。</p><p>as-if-serial语义把<strong>单线程</strong>程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p><blockquote><p>重点！解释下什么是as-if-serial语义，因为这是这道题的第一个关键词，答上来就对了一半了</p></blockquote><p>再说下synchronized，他是Java提供的锁，可以通过他对Java中的对象加锁，并且他是一种排他的、可重入的锁。</p><p>所以，当某个线程执行到一段被synchronized修饰的代码之前，会先进行加锁，执行完之后再进行解锁。在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。</p><blockquote><p>介绍synchronized的原理，这是本题的第二个关键点，到这里基本就可以拿满分了。</p></blockquote><p>synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。所以呢，这就满足了as-if-serial语义的一个关键前提，那就是<strong>单线程</strong>，因为有as-if-serial语义保证，单线程的有序性就天然存在了。</p><h2 id="来源" tabindex="-1"><a class="header-anchor" href="#来源"><span>来源</span></a></h2><p>https://mp.weixin.qq.com/s/Pd6dOXaMQFUHfAUnOhnwtw</p>',17)],l={},o=(0,i(66262).A)(l,[["render",function(e,t){return(0,a.uX)(),(0,a.CE)("div",null,n)}]]),r=JSON.parse('{"path":"/study-notes/shangguigu-second/lock/five.html","title":"为什么Synchronized无法禁止指令重排，却能保证有序性","lang":"zh-CN","frontmatter":{"title":"为什么Synchronized无法禁止指令重排，却能保证有序性","date":"2023-03-18T00:00:00.000Z","tags":["锁"],"description":"前言 首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念： Java内存模型 并发编程有序性问题 指令重排 synchronized锁 可重入锁 排它锁 as-if-serial语义 单线程&多线程 标准解答 为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/./study-notes/shangguigu-second/lock/five.html"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"为什么Synchronized无法禁止指令重排，却能保证有序性"}],["meta",{"property":"og:description","content":"前言 首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念： Java内存模型 并发编程有序性问题 指令重排 synchronized锁 可重入锁 排它锁 as-if-serial语义 单线程&多线程 标准解答 为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-11T14:10:10.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:published_time","content":"2023-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-11T14:10:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么Synchronized无法禁止指令重排，却能保证有序性\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-11T14:10:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"标准解答","slug":"标准解答","link":"#标准解答","children":[]},{"level":2,"title":"来源","slug":"来源","link":"#来源","children":[]}],"git":{"createdTime":1722089104000,"updatedTime":1723385410000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":2}]},"readingTime":{"minutes":2.37,"words":712},"filePathRelative":"study-notes/shangguigu-second/lock/five.md","localizedDate":"2023年3月18日","excerpt":"<h2>前言</h2>\\n<p>首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念：</p>\\n<ul>\\n<li>Java内存模型</li>\\n<li>并发编程有序性问题</li>\\n<li>指令重排</li>\\n<li>synchronized锁</li>\\n<li>可重入锁</li>\\n<li>排它锁</li>\\n<li>as-if-serial语义</li>\\n<li>单线程&amp;多线程</li>\\n</ul>\\n<h2>标准解答</h2>\\n<p>为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p>","autoDesc":true}')}}]);