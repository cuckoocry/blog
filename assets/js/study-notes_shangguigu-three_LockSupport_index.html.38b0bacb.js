"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[5646],{66262:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,s]of a)i[e]=s;return i}},80991:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>r,data:()=>p});var s=i(20641);const n=i.p+"assets/img/image-20210918201339817.9c085e9f.png",t=[(0,s.Fv)('<h2 id="locksupport是什么" tabindex="-1"><a class="header-anchor" href="#locksupport是什么"><span>LockSupport是什么</span></a></h2><ol><li>为什么要学习LockSupport <ol><li>Java -------jvm</li><li>JUC ------- AQS ------&gt; （前置知识、可重入锁、LockSupport）</li></ol></li><li>学习方法 <ol><li>是什么</li><li>能干吗</li><li>去哪下</li><li>怎么玩</li></ol></li><li>AB -&gt; after/ before</li></ol><h3 id="ab-after-before" tabindex="-1"><a class="header-anchor" href="#ab-after-before"><span><strong>AB -&gt; after/ before</strong></span></a></h3><figure><img src="'+n+'" alt="image-20210918201339817" tabindex="0" loading="lazy"><figcaption>image-20210918201339817</figcaption></figure><h3 id="学习方法" tabindex="-1"><a class="header-anchor" href="#学习方法"><span>学习方法</span></a></h3><p>API网站地址：https://www.apiref.com/java11-zh/java.base/module-summary.html</p><p>找到 java.util.concurrent.locks ----&gt; LockSupport (用于创建锁和其他同步类的基本线程阻塞原语。)</p><p>该类与使用它的每个线程关联一个许可证（在<a href="https://www.apiref.com/java11-zh/java.base/java/util/concurrent/Semaphore.html" target="_blank" rel="noopener noreferrer"><code>Semaphore</code></a>类的意义上）。</p><div class="language-dockerfile line-numbers-mode" data-highlighter="shiki" data-ext="dockerfile" data-title="dockerfile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">模块  java.base</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">软件包  java.util.concurrent.locks</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">java.lang.Object</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">java.util.concurrent.locks.LockSupport</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">public class LockSupport</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">extends Object</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">用于创建锁和其他同步类的基本线程阻塞原语。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">该类与使用它的每个线程关联一个许可证（在Semaphore类的意义上）。 如果许可证可用，将立即返回park ，并在此过程中消费; 否则可能会阻止。 如果尚未提供许可，则致电unpark获得许可。 （与Semaphores不同，许可证不会累积。最多只有一个。）可靠的使用需要使用volatile（或原子）变量来控制何时停放或取消停放。 对于易失性变量访问保持对这些方法的调用的顺序，但不一定是非易失性变量访问。</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">方法park和unpark提供了阻止和解除阻塞线程的有效方法，这些线程没有遇到导致不推荐使用的方法Thread.suspend和Thread.resume无法用于此类目的的问题：一个线程调用park和另一个线程尝试unpark将保留活跃性，由于许可证。 此外，如果调用者的线程被中断，则会返回park ，并且支持超时版本。 park方法也可以在任何其他时间返回，“无理由”，因此通常必须在返回时重新检查条件的循环内调用。 在这个意义上， park可以作为“忙碌等待”的优化，不会浪费太多时间旋转，但必须与unpark配对才能生效。</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">三种形式的park每个也支持blocker对象参数。 在线程被阻塞时记录此对象，以允许监视和诊断工具识别线程被阻止的原因。 （此类工具可以使用方法getBlocker(Thread)访问阻止程序 。）强烈建议使用这些表单而不是没有此参数的原始表单。 在锁实现中作为blocker提供的正常参数是this 。</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">这些方法旨在用作创建更高级别同步实用程序的工具，并且对于大多数并发控制应用程序本身并不有用。 park方法仅用于以下形式的构造：</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   while (!canProceed()) { // ensure request to unpark is visible to other threads ... LockSupport.park(this); } </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">在调用park之前，线程没有发布请求park需要锁定或阻塞。 因为每个线程只有一个许可证，所以任何中间使用park ，包括隐式地通过类加载，都可能导致无响应的线程（“丢失unpark”）。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简言之LockSupport就是线程等待唤醒机制（wait/notify）的改良加强版</p><p><code>LockSupport中的park()和 unpark()的作用分别是阻塞线程和解除阻塞线程。</code></p><p>总之，比wait/notify，await/signal更强。</p>',12)],l={},r=(0,i(66262).A)(l,[["render",function(e,a){return(0,s.uX)(),(0,s.CE)("div",null,t)}]]),p=JSON.parse('{"path":"/study-notes/shangguigu-three/LockSupport/","title":"LockSupport","lang":"zh-CN","frontmatter":{"title":"LockSupport","date":"2023-03-18T00:00:00.000Z","description":"LockSupport是什么 为什么要学习LockSupport Java -------jvm JUC ------- AQS ------\x3e （前置知识、可重入锁、LockSupport） 学习方法 是什么 能干吗 去哪下 怎么玩 AB -> after/ before AB -> after/ before image-2021091820133...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-three/LockSupport/"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"LockSupport"}],["meta",{"property":"og:description","content":"LockSupport是什么 为什么要学习LockSupport Java -------jvm JUC ------- AQS ------\x3e （前置知识、可重入锁、LockSupport） 学习方法 是什么 能干吗 去哪下 怎么玩 AB -> after/ before AB -> after/ before image-2021091820133..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-11T14:10:10.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:published_time","content":"2023-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-11T14:10:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LockSupport\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-11T14:10:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"LockSupport是什么","slug":"locksupport是什么","link":"#locksupport是什么","children":[{"level":3,"title":"AB -> after/ before","slug":"ab-after-before","link":"#ab-after-before","children":[]},{"level":3,"title":"学习方法","slug":"学习方法","link":"#学习方法","children":[]}]}],"git":{"createdTime":1722090295000,"updatedTime":1723385410000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":2}]},"readingTime":{"minutes":2.66,"words":797},"filePathRelative":"study-notes/shangguigu-three/LockSupport/README.md","localizedDate":"2023年3月18日","excerpt":"<h2>LockSupport是什么</h2>\\n<ol>\\n<li>为什么要学习LockSupport\\n<ol>\\n<li>Java -------jvm</li>\\n<li>JUC ------- AQS ------&gt; （前置知识、可重入锁、LockSupport）</li>\\n</ol>\\n</li>\\n<li>学习方法\\n<ol>\\n<li>是什么</li>\\n<li>能干吗</li>\\n<li>去哪下</li>\\n<li>怎么玩</li>\\n</ol>\\n</li>\\n<li>AB -&gt; after/ before</li>\\n</ol>\\n<h3><strong>AB -&gt; after/ before</strong></h3>","autoDesc":true}')}}]);