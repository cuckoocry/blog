"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[4473],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}},97918:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>d,data:()=>r});var i=a(20641);const e=a.p+"assets/img/image-20200317101210376.2c478095.png",l=a.p+"assets/img/image-20200317105121435.963a123f.png",p=[(0,i.Fv)('<p>早期的时候我们对线程的主要操作为：</p><ul><li>synchronized wait notify</li></ul><p>然后后面出现了替代方案</p><ul><li>lock await signal</li></ul><figure><img src="'+e+'" alt="image-20200317101210376" tabindex="0" loading="lazy"><figcaption>image-20200317101210376</figcaption></figure><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><h3 id="synchronized-和-lock-有什么区别-用新的lock有什么好处-举例说明" tabindex="-1"><a class="header-anchor" href="#synchronized-和-lock-有什么区别-用新的lock有什么好处-举例说明"><span>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</span></a></h3><ul><li>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</li></ul><p>1）synchronized属于JVM层面，属于java的关键字</p><ul><li>​ monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象 只能在同步块或者方法中才能调用 wait/ notify等方法）</li><li>Lock是具体类（java.util.concurrent.locks.Lock）是api层面的锁</li></ul><p>2）使用方法：</p><ul><li><p>synchronized：不需要用户去手动释放锁，当synchronized代码执行后，系统会自动让线程释放对锁的占用</p></li><li><p>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要lock() 和 unlock() 配置try catch语句来完成</p></li></ul><p>3）等待是否中断</p><ul><li>synchronized：不可中断，除非抛出异常或者正常运行完成</li><li>ReentrantLock：可中断，可以设置超时方法 <ul><li>设置超时方法，trylock(long timeout, TimeUnit unit)</li><li>lockInterrupible() 放代码块中，调用interrupt() 方法可以中断</li></ul></li></ul><p>4）加锁是否公平</p><ul><li>synchronized：非公平锁</li><li>ReentrantLock：默认非公平锁，构造函数可以传递boolean值，true为公平锁，false为非公平锁</li></ul><p>5）锁绑定多个条件Condition</p><ul><li>synchronized：没有，要么随机，要么全部唤醒</li><li>ReentrantLock：用来实现分组唤醒需要唤醒的线程，可以精确唤醒，而不是像synchronized那样，要么随机，要么全部唤醒</li></ul><h2 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例</span></a></h2><p>针对刚刚提到的区别的第5条，我们有下面这样的一个场景</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>题目：多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：</span></span>\n<span class="line"><span>AA打印5次，BB打印10次，CC打印15次</span></span>\n<span class="line"><span>紧接着</span></span>\n<span class="line"><span>AA打印5次，BB打印10次，CC打印15次</span></span>\n<span class="line"><span>..</span></span>\n<span class="line"><span>来10轮</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现，这样的场景在使用synchronized来完成的话，会非常的困难，但是使用lock就非常方便了</p><p>也就是我们需要实现一个链式唤醒的操作</p><figure><img src="'+l+'" alt="image-20200317105121435" tabindex="0" loading="lazy"><figcaption>image-20200317105121435</figcaption></figure><p>当A线程执行完后，B线程才能执行，然后B线程执行完成后，C线程才执行</p><p>首先我们需要创建一个重入锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 创建一个重入锁</span></span>\n<span class="line"><span>private Lock lock = new ReentrantLock();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后定义三个条件，也可以称为锁的钥匙，通过它就可以获取到锁，进入到方法里面</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 这三个相当于备用钥匙</span></span>\n<span class="line"><span>private Condition condition1 = lock.newCondition();</span></span>\n<span class="line"><span>private Condition condition2 = lock.newCondition();</span></span>\n<span class="line"><span>private Condition condition3 = lock.newCondition();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后开始记住锁的三部曲： 判断 干活 唤醒</p><p>这里的判断，为了避免虚假唤醒，一定要采用 while</p><p>干活就是把需要的内容，打印出来</p><p>唤醒的话，就是修改资源类的值，然后精准唤醒线程进行干活：这里A 唤醒B， B唤醒C，C又唤醒A</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public void print5() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 判断</span></span>\n<span class="line"><span>            while(number != 1) {</span></span>\n<span class="line"><span>                // 不等于1，需要等待</span></span>\n<span class="line"><span>                condition1.await();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 干活</span></span>\n<span class="line"><span>            for (int i = 0; i &lt; 5; i++) {</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t &quot; + number + &quot;\\t&quot; + i);</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 唤醒 （干完活后，需要通知B线程执行）</span></span>\n<span class="line"><span>            number = 2;</span></span>\n<span class="line"><span>            // 通知2号去干活了</span></span>\n<span class="line"><span>            condition2.signal();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span> * Synchronized 和 Lock的区别</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2023-03-04</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>class ShareResource {</span></span>\n<span class="line"><span>    // A 1   B 2   c 3</span></span>\n<span class="line"><span>    private int number = 1;</span></span>\n<span class="line"><span>    // 创建一个重入锁</span></span>\n<span class="line"><span>    private Lock lock = new ReentrantLock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 这三个相当于备用钥匙</span></span>\n<span class="line"><span>    private Condition condition1 = lock.newCondition();</span></span>\n<span class="line"><span>    private Condition condition2 = lock.newCondition();</span></span>\n<span class="line"><span>    private Condition condition3 = lock.newCondition();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void print5() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 判断</span></span>\n<span class="line"><span>            while(number != 1) {</span></span>\n<span class="line"><span>                // 不等于1，需要等待</span></span>\n<span class="line"><span>                condition1.await();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 干活</span></span>\n<span class="line"><span>            for (int i = 0; i &lt; 5; i++) {</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t &quot; + number + &quot;\\t&quot; + i);</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 唤醒 （干完活后，需要通知B线程执行）</span></span>\n<span class="line"><span>            number = 2;</span></span>\n<span class="line"><span>            // 通知2号去干活了</span></span>\n<span class="line"><span>            condition2.signal();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void print10() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 判断</span></span>\n<span class="line"><span>            while(number != 2) {</span></span>\n<span class="line"><span>                // 不等于2，需要等待</span></span>\n<span class="line"><span>                condition2.await();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 干活</span></span>\n<span class="line"><span>            for (int i = 0; i &lt; 10; i++) {</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t &quot; + number + &quot;\\t&quot; + i);</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 唤醒 （干完活后，需要通知C线程执行）</span></span>\n<span class="line"><span>            number = 3;</span></span>\n<span class="line"><span>            // 通知2号去干活了</span></span>\n<span class="line"><span>            condition3.signal();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void print15() {</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 判断</span></span>\n<span class="line"><span>            while(number != 3) {</span></span>\n<span class="line"><span>                // 不等于3，需要等待</span></span>\n<span class="line"><span>                condition3.await();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 干活</span></span>\n<span class="line"><span>            for (int i = 0; i &lt; 15; i++) {</span></span>\n<span class="line"><span>                System.out.println(Thread.currentThread().getName() + &quot;\\t &quot; + number + &quot;\\t&quot; + i);</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            // 唤醒 （干完活后，需要通知C线程执行）</span></span>\n<span class="line"><span>            number = 1;</span></span>\n<span class="line"><span>            // 通知1号去干活了</span></span>\n<span class="line"><span>            condition1.signal();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>public class SyncAndReentrantLockDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        ShareResource shareResource = new ShareResource();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            for (int i = 0; i &lt; 10; i++) {</span></span>\n<span class="line"><span>                    shareResource.print5();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;A&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            for (int i = 0; i &lt; 10; i++) {</span></span>\n<span class="line"><span>                shareResource.print10();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;B&quot;).start();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        new Thread(() -&gt; {</span></span>\n<span class="line"><span>            for (int i = 0; i &lt; 10; i++) {</span></span>\n<span class="line"><span>                shareResource.print15();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }, &quot;C&quot;).start();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',35)],c={},d=(0,a(66262).A)(c,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,p)}]]),r=JSON.parse('{"path":"/study-notes/shangguigu-second/Synchronized-Lock/","title":"8、Synchronized和Lock的区别","lang":"zh-CN","frontmatter":{"title":"8、Synchronized和Lock的区别","date":"2023-03-11T00:00:00.000Z","tags":["Synchronized","Lock"],"category":["JUC"],"description":"早期的时候我们对线程的主要操作为： synchronized wait notify 然后后面出现了替代方案 lock await signal image-20200317101210376image-20200317101210376 问题 synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明 synchroniz...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/study-notes/shangguigu-second/Synchronized-Lock/"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"8、Synchronized和Lock的区别"}],["meta",{"property":"og:description","content":"早期的时候我们对线程的主要操作为： synchronized wait notify 然后后面出现了替代方案 lock await signal image-20200317101210376image-20200317101210376 问题 synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明 synchroniz..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"Synchronized"}],["meta",{"property":"article:tag","content":"Lock"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"8、Synchronized和Lock的区别\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[{"level":3,"title":"synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明","slug":"synchronized-和-lock-有什么区别-用新的lock有什么好处-举例说明","link":"#synchronized-和-lock-有什么区别-用新的lock有什么好处-举例说明","children":[]}]},{"level":2,"title":"举例","slug":"举例","link":"#举例","children":[]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":3.91,"words":1172},"filePathRelative":"study-notes/shangguigu-second/Synchronized-Lock/README.md","localizedDate":"2023年3月11日","excerpt":"<p>早期的时候我们对线程的主要操作为：</p>\\n<ul>\\n<li>synchronized wait  notify</li>\\n</ul>\\n<p>然后后面出现了替代方案</p>\\n<ul>\\n<li>lock await  signal</li>\\n</ul>\\n<figure><figcaption>image-20200317101210376</figcaption></figure>\\n<h2>问题</h2>\\n<h3>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</h3>\\n<ul>\\n<li>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</li>\\n</ul>","autoDesc":true}')}}]);