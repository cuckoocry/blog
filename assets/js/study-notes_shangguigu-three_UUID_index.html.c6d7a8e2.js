"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[1730],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}},53812:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>r,data:()=>t});var i=a(20641);const e=a.p+"assets/img/image-20200418080900190.acb9dd01.png",l=a.p+"assets/img/image-20200418083435048.f3b36dcb.png",p=a.p+"assets/img/image-20200418091447935.d0cd51a9.png",d=[(0,i.Fv)('<h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><h3 id="为什么需要分布式全局唯一id以及分布式id的业务需求" tabindex="-1"><a class="header-anchor" href="#为什么需要分布式全局唯一id以及分布式id的业务需求"><span>为什么需要分布式全局唯一ID以及分布式ID的业务需求</span></a></h3><p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识，如在美团点评的金融、支付、餐饮、酒店</p><p>猫眼电影等产品的系统中数据逐渐增长，对数据库分库分表后需要有一个唯一ID来标识一条数据或信息；</p><p>特别Ian的订单、骑手、优惠券都需要有唯一ID做标识</p><p>此时一个能够生成全局唯一ID的系统是非常必要的</p><figure><img src="'+e+'" alt="image-20200418080900190" tabindex="0" loading="lazy"><figcaption>image-20200418080900190</figcaption></figure><h3 id="id生成规则部分硬性要求" tabindex="-1"><a class="header-anchor" href="#id生成规则部分硬性要求"><span>ID生成规则部分硬性要求</span></a></h3><ul><li>全局唯一</li><li>趋势递增 <ul><li>在MySQL的InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用Btree的数据结构来存储索引，在主键的选择上面我们应该尽量使用有序的主键保证写入性能</li></ul></li><li>单调递增 <ul><li>保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求</li></ul></li><li>信息安全 <ul><li>如果ID是连续，恶意用户的爬取工作就非常容易做了，直接按照顺序下载指定URL即可，如果是订单号就危险了，竞争对手可以直接知道我们一天的单量，所以在一些应用场景下，需要ID无规则不规则，让竞争对手不好猜</li></ul></li><li>含时间戳 <ul><li>一样能够快速在开发中了解这个分布式ID什么时候生成的</li></ul></li></ul><h3 id="id号生成系统的可用性要求" tabindex="-1"><a class="header-anchor" href="#id号生成系统的可用性要求"><span>ID号生成系统的可用性要求</span></a></h3><ul><li>高可用 <ul><li>发布一个获取分布式ID请求，服务器就要保证99.999%的情况下给我创建一个唯一分布式ID</li></ul></li><li>低延迟 <ul><li>发一个获取分布式ID的请求，服务器就要快，极速</li></ul></li><li>高QPS <ul><li>例如并发一口气10万个创建分布式ID请求同时杀过来，服务器要顶得住且一下子成功创建10万个分布式ID</li></ul></li></ul><h2 id="一般通用解决方案" tabindex="-1"><a class="header-anchor" href="#一般通用解决方案"><span>一般通用解决方案</span></a></h2><h3 id="uuid" tabindex="-1"><a class="header-anchor" href="#uuid"><span>UUID</span></a></h3><p><code>UUID.randomUUID()</code> , UUID的标准型包含32个16进制数字，以连字号分为五段，形式为 8-4-4-4-12的36个字符，性能非常高，本地生成，没有网络消耗。</p><h4 id="存在问题" tabindex="-1"><a class="header-anchor" href="#存在问题"><span>存在问题</span></a></h4><p>入数据库性能差，因为UUID是无序的</p><ul><li>无序，无法预测他的生成顺序，不能生成递增有序的数字</li></ul><p>首先分布式id一般都会作为逐渐，但是按照mysql官方推荐主键尽量越短越好，UUID每一个都很长，所以不是很推荐。</p><ul><li>主键，ID作为主键时，在特定的环境下会存在一些问题</li></ul><p>比如做DB主键的场景下，UUID就非常不适用MySQL官方有明确的说明</p><ul><li>索引，B+树索引的分裂</li></ul><p>既然分布式ID是主键，然后主键是包含索引的，而mysql的索引是通过B+树来实现的，每一次新的UUID数据的插入，为了查询的优化，都会对索引底层的B+树进行修改，因为UUID数据是无序的，所以每一次UUID数据的插入都会对主键的B+树进行很大的修改，这一点很不好，插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。</p><p>UUID只能保证全局唯一性，不满足后面的趋势递增，单调递增</p><h3 id="数据库自增主键" tabindex="-1"><a class="header-anchor" href="#数据库自增主键"><span>数据库自增主键</span></a></h3><h4 id="单机" tabindex="-1"><a class="header-anchor" href="#单机"><span>单机</span></a></h4><p>在分布式里面，数据库的自增ID机制的主要原理是：数据库自增ID和mysql数据库的replace into实现的，这里的replace into跟insert功能 类似，不同点在于：replace into首先尝试插入数据列表中，如果发现表中已经有此行数据（根据主键或唯一索引判断）则先删除，在插入，否则直接插入新数据。</p><p>REPLACE INTO的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换老数据</p><figure><img src="'+l+'" alt="image-20200418083435048" tabindex="0" loading="lazy"><figcaption>image-20200418083435048</figcaption></figure><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>REPLACE into t_test(stub) values(&#39;b&#39;);</span></span>\n<span class="line"><span>select LAST_INSERT_ID();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们每次插入的时候，发现都会把原来的数据给替换，并且ID也会增加</p><p>这就满足了</p><ul><li>递增性</li><li>单调性</li><li>唯一性</li></ul><p>在分布式情况下，并且并发量不多的情况，可以使用这种方案来解决，获得一个全局的唯一ID</p><h4 id="集群分布式集群" tabindex="-1"><a class="header-anchor" href="#集群分布式集群"><span>集群分布式集群</span></a></h4><p>那数据库自增ID机制适合做分布式ID吗？答案是不太适合</p><p>系统水平扩展比较困难，比如定义好步长和机器台数之后，如果要添加机器该怎么办，假设现在有一台机器发号是：1,2,3,4,5,（步长是1），这个时候需要扩容机器一台，可以这样做：把第二胎机器的初始值设置得比第一台超过很多，貌似还好，但是假设线上如果有100台机器，这个时候扩容要怎么做，简直是噩梦，所以系统水平扩展方案复杂难以实现。</p><p>数据库压力还是很大，每次获取ID都得读写一次数据库，非常影响性能，不符合分布式ID里面的延迟低和高QPS的规则（在高并发下，如果都去数据库里面获取ID，那是非常影响性能的）</p><h3 id="基于redis生成全局id策略" tabindex="-1"><a class="header-anchor" href="#基于redis生成全局id策略"><span>基于Redis生成全局ID策略</span></a></h3><h4 id="单机版" tabindex="-1"><a class="header-anchor" href="#单机版"><span>单机版</span></a></h4><p>因为Redis是单线程，天生保证原子性，可以使用原子操作INCR和INCRBY来实现</p><p>INCRBY：设置增长步长</p><h4 id="集群分布式" tabindex="-1"><a class="header-anchor" href="#集群分布式"><span>集群分布式</span></a></h4><p>注意：在Redis集群情况下，同样和MySQL一样需要设置不同的增长步长，同时key一定要设置有效期，可以使用Redis集群来获取更高的吞吐量。</p><p>假设一个集群中有5台Redis，可以初始化每台Redis的值分别是 1,2,3,4,5 ， 然后设置步长都是5</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>各个Redis生成的ID为：</span></span>\n<span class="line"><span>A：1 6 11 16 21</span></span>\n<span class="line"><span>B：2 7 12 17 22</span></span>\n<span class="line"><span>C：3 8 13 18 23</span></span>\n<span class="line"><span>D：4 9 14 19 24</span></span>\n<span class="line"><span>E：5 10 15 20 25</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是存在的问题是，就是Redis集群的维护和保养比较麻烦，配置麻烦。因为要设置单点故障，哨兵值守</p><p>但是主要是的问题就是，为了一个ID，却需要引入整个Redis集群，有种杀鸡焉用牛刀的感觉</p><h2 id="雪花算法" tabindex="-1"><a class="header-anchor" href="#雪花算法"><span>雪花算法</span></a></h2><h3 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么"><span>是什么</span></a></h3><p>Twitter的分布式自增ID算法，Snowflake</p><p>最初Twitter把存储系统从MySQL迁移到Cassandra（由Facebook开发一套开源分布式NoSQL数据库系统）因为Cassandra没有顺序ID生成机制，所有开发了这样一套全局唯一ID生成服务。</p><p>Twitter的分布式雪花算法SnowFlake，经测试SnowFlake每秒可以产生26万个自增可排序的ID</p><ul><li>twitter的SnowFlake生成ID能够按照时间有序生成</li><li>SnowFlake算法生成ID的结果是一个64Bit大小的整数，为一个Long型（转换成字符串后长度最多19）</li><li>分布式系统内不会产生ID碰撞（由datacenter 和 workerID做区分）并且效率较高</li></ul><p>分布式系统中，有一些需要全局唯一ID的场景，生成ID的基本要求</p><ul><li>在分布式环境下，必须全局唯一性</li><li>一般都需要单调递增，因为一般唯一ID都会存在数据库，而InnoDB的特性就是将内容存储在主键索引上的叶子节点，而且是从左往右递增的，所有考虑到数据库性能，一般生成ID也最好是单调递增的。为了防止ID冲突可以使用36位UUID，但是UUID有一些缺点，首先是它相对比较长，并且另外UUID一般是无序的</li><li>可能还会需要无规则，因为如果使用唯一ID作为订单号这种，为了不让别人知道一天的订单量多少，就需要这种规则</li></ul><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h3><p>雪花算法的几个核心组成部分</p><figure><img src="'+p+'" alt="image-20200418091447935" tabindex="0" loading="lazy"><figcaption>image-20200418091447935</figcaption></figure><p>在Java中64bit的证书是long类型，所以在SnowFlake算法生成的ID就是long类存储的</p><h4 id="第一部分" tabindex="-1"><a class="header-anchor" href="#第一部分"><span>第一部分</span></a></h4><p>二进制中最高位是符号位，1表示负数，0表示正数。生成的ID一般都是用整数，所以最高位固定为0。</p><h4 id="第二部分" tabindex="-1"><a class="header-anchor" href="#第二部分"><span>第二部分</span></a></h4><p>第二部分是41bit时间戳位，用来记录时间戳，毫秒级</p><p>41位可以表示 2^41 -1 个数字</p><p>如果只用来表示正整数，可以表示的范围是： 0 - 2^41 -1，减1是因为可以表示的数值范围是从0开始计算的，而不是从1。</p><p>也就是说41位可以表示 2^41 - 1 毫秒的值，转换成单位年则是 69.73年</p><h4 id="第三部分" tabindex="-1"><a class="header-anchor" href="#第三部分"><span>第三部分</span></a></h4><p>第三部分为工作机器ID，10Bit用来记录工作机器ID</p><p>可以部署在2^10 = 1024个节点，包括5位 datacenterId（数据中心，机房） 和 5位 workerID（机器码）</p><p>5位可以表示的最大正整数是 2 ^ 5 = 31个数字，来表示不同的数据中心 和 机器码</p><h4 id="第四部分" tabindex="-1"><a class="header-anchor" href="#第四部分"><span>第四部分</span></a></h4><p>12位bit可以用来表示的正整数是 2^12 = 4095，即可以用0 1 2 .... 4094 来表示同一个机器同一个时间戳内产生的4095个ID序号。</p><h4 id="snowflake可以保证" tabindex="-1"><a class="header-anchor" href="#snowflake可以保证"><span>SnowFlake可以保证</span></a></h4><p>所有生成的ID按时间趋势递增</p><p>整个分布式系统内不会产生重复ID，因为有datacenterId 和 workerId来做区分</p><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h3><p>雪花算法是由scala算法编写的，有人使用java实现，<a href="https://github.com/beyondfengyu/SnowFlake/blob/master/SnowFlake.java" target="_blank" rel="noopener noreferrer">github地址</a></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * twitter的snowflake算法 -- java实现</span></span>\n<span class="line"><span> * </span></span>\n<span class="line"><span> * @author beyond</span></span>\n<span class="line"><span> * @date 2016/11/26</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class SnowFlake {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 起始的时间戳</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    private final static long START_STMP = 1480166465631L;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 每一部分占用的位数</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    private final static long SEQUENCE_BIT = 12; //序列号占用的位数</span></span>\n<span class="line"><span>    private final static long MACHINE_BIT = 5;   //机器标识占用的位数</span></span>\n<span class="line"><span>    private final static long DATACENTER_BIT = 5;//数据中心占用的位数</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 每一部分的最大值</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    private final static long MAX_DATACENTER_NUM = -1L ^ (-1L &lt;&lt; DATACENTER_BIT);</span></span>\n<span class="line"><span>    private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT);</span></span>\n<span class="line"><span>    private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 每一部分向左的位移</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    private final static long MACHINE_LEFT = SEQUENCE_BIT;</span></span>\n<span class="line"><span>    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span></span>\n<span class="line"><span>    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private long datacenterId;  //数据中心</span></span>\n<span class="line"><span>    private long machineId;     //机器标识</span></span>\n<span class="line"><span>    private long sequence = 0L; //序列号</span></span>\n<span class="line"><span>    private long lastStmp = -1L;//上一次时间戳</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public SnowFlake(long datacenterId, long machineId) {</span></span>\n<span class="line"><span>        if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) {</span></span>\n<span class="line"><span>            throw new IllegalArgumentException(&quot;datacenterId can&#39;t be greater than MAX_DATACENTER_NUM or less than 0&quot;);</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) {</span></span>\n<span class="line"><span>            throw new IllegalArgumentException(&quot;machineId can&#39;t be greater than MAX_MACHINE_NUM or less than 0&quot;);</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        this.datacenterId = datacenterId;</span></span>\n<span class="line"><span>        this.machineId = machineId;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 产生下一个ID</span></span>\n<span class="line"><span>     *</span></span>\n<span class="line"><span>     * @return</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public synchronized long nextId() {</span></span>\n<span class="line"><span>        long currStmp = getNewstmp();</span></span>\n<span class="line"><span>        if (currStmp &lt; lastStmp) {</span></span>\n<span class="line"><span>            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        if (currStmp == lastStmp) {</span></span>\n<span class="line"><span>            //相同毫秒内，序列号自增</span></span>\n<span class="line"><span>            sequence = (sequence + 1) &amp; MAX_SEQUENCE;</span></span>\n<span class="line"><span>            //同一毫秒的序列数已经达到最大</span></span>\n<span class="line"><span>            if (sequence == 0L) {</span></span>\n<span class="line"><span>                currStmp = getNextMill();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        } else {</span></span>\n<span class="line"><span>            //不同毫秒内，序列号置为0</span></span>\n<span class="line"><span>            sequence = 0L;</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        lastStmp = currStmp;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        return (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT //时间戳部分</span></span>\n<span class="line"><span>                | datacenterId &lt;&lt; DATACENTER_LEFT       //数据中心部分</span></span>\n<span class="line"><span>                | machineId &lt;&lt; MACHINE_LEFT             //机器标识部分</span></span>\n<span class="line"><span>                | sequence;                             //序列号部分</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private long getNextMill() {</span></span>\n<span class="line"><span>        long mill = getNewstmp();</span></span>\n<span class="line"><span>        while (mill &lt;= lastStmp) {</span></span>\n<span class="line"><span>            mill = getNewstmp();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        return mill;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private long getNewstmp() {</span></span>\n<span class="line"><span>        return System.currentTimeMillis();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        SnowFlake snowFlake = new SnowFlake(2, 3);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        for (int i = 0; i &lt; (1 &lt;&lt; 12); i++) {</span></span>\n<span class="line"><span>            System.out.println(snowFlake.nextId());</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="工程落地经验" tabindex="-1"><a class="header-anchor" href="#工程落地经验"><span>工程落地经验</span></a></h3><h4 id="hutools工具包" tabindex="-1"><a class="header-anchor" href="#hutools工具包"><span>hutools工具包</span></a></h4><p>地址：https://github.com/looly/hutool</p><h4 id="springboot整合雪花算法" tabindex="-1"><a class="header-anchor" href="#springboot整合雪花算法"><span>SpringBoot整合雪花算法</span></a></h4><p>引入hutool工具类</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>\n<span class="line"><span>    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span></span>\n<span class="line"><span>    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span></span>\n<span class="line"><span>    &lt;version&gt;5.3.1&lt;/version&gt;</span></span>\n<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整合</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 雪花算法</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-04-18-11:08</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class SnowFlakeDemo {</span></span>\n<span class="line"><span>    private long workerId = 0;</span></span>\n<span class="line"><span>    private long datacenterId = 1;</span></span>\n<span class="line"><span>    private Snowflake snowFlake = IdUtil.createSnowflake(workerId, datacenterId);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    @PostConstruct</span></span>\n<span class="line"><span>    public void init() {</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 将网络ip转换成long</span></span>\n<span class="line"><span>            workerId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr());</span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 获取雪花ID</span></span>\n<span class="line"><span>     * @return</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public synchronized long snowflakeId() {</span></span>\n<span class="line"><span>        return this.snowFlake.nextId();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public synchronized long snowflakeId(long workerId, long datacenterId) {</span></span>\n<span class="line"><span>        Snowflake snowflake = IdUtil.createSnowflake(workerId, datacenterId);</span></span>\n<span class="line"><span>        return snowflake.nextId();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span>        SnowFlakeDemo snowFlakeDemo = new SnowFlakeDemo();</span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 20; i++) {</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                System.out.println(snowFlakeDemo.snowflakeId());</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1251350711346790400</span></span>\n<span class="line"><span>1251350711346790402</span></span>\n<span class="line"><span>1251350711346790401</span></span>\n<span class="line"><span>1251350711346790403</span></span>\n<span class="line"><span>1251350711346790405</span></span>\n<span class="line"><span>1251350711346790404</span></span>\n<span class="line"><span>1251350711346790406</span></span>\n<span class="line"><span>1251350711346790407</span></span>\n<span class="line"><span>1251350711350984704</span></span>\n<span class="line"><span>1251350711350984706</span></span>\n<span class="line"><span>1251350711350984705</span></span>\n<span class="line"><span>1251350711350984707</span></span>\n<span class="line"><span>1251350711350984708</span></span>\n<span class="line"><span>1251350711350984709</span></span>\n<span class="line"><span>1251350711350984710</span></span>\n<span class="line"><span>1251350711350984711</span></span>\n<span class="line"><span>1251350711350984712</span></span>\n<span class="line"><span>1251350711355179008</span></span>\n<span class="line"><span>1251350711355179009</span></span>\n<span class="line"><span>1251350711355179010</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h3><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h4><ul><li>毫秒数在高维，自增序列在低位，整个ID都是趋势递增的</li><li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的</li><li>可以根据自身业务特性分配bit位，非常灵活</li></ul><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h4><ul><li>依赖机器时钟，如果机器时钟回拨，会导致重复ID生成</li><li>在单机上是递增的，但由于涉及到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况，此缺点可以认为无所谓，一般分布式ID只要求趋势递增，并不会严格要求递增，90%的需求只要求趋势递增。</li></ul><h4 id="其它补充" tabindex="-1"><a class="header-anchor" href="#其它补充"><span>其它补充</span></a></h4><p>为了解决时钟回拨问题，导致ID重复，后面有人专门提出了解决的方案</p><ul><li>百度开源的分布式唯一ID生成器 UidGenerator</li><li>Leaf - 美团点评分布式ID生成系统</li></ul>',96)],c={},r=(0,a(66262).A)(c,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,d)}]]),t=JSON.parse('{"path":"/study-notes/shangguigu-three/UUID/","title":"集群高并发情况下如何保证分布式唯一全局Id生成","lang":"zh-CN","frontmatter":{"title":"集群高并发情况下如何保证分布式唯一全局Id生成","date":"2023-03-11T00:00:00.000Z","tags":["redis"],"description":"问题 为什么需要分布式全局唯一ID以及分布式ID的业务需求 在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识，如在美团点评的金融、支付、餐饮、酒店 猫眼电影等产品的系统中数据逐渐增长，对数据库分库分表后需要有一个唯一ID来标识一条数据或信息； 特别Ian的订单、骑手、优惠券都需要有唯一ID做标识 此时一个能够生成全局唯一ID的系统是非常必要的...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-three/UUID/"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"集群高并发情况下如何保证分布式唯一全局Id生成"}],["meta",{"property":"og:description","content":"问题 为什么需要分布式全局唯一ID以及分布式ID的业务需求 在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识，如在美团点评的金融、支付、餐饮、酒店 猫眼电影等产品的系统中数据逐渐增长，对数据库分库分表后需要有一个唯一ID来标识一条数据或信息； 特别Ian的订单、骑手、优惠券都需要有唯一ID做标识 此时一个能够生成全局唯一ID的系统是非常必要的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-11T14:10:10.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-11T14:10:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"集群高并发情况下如何保证分布式唯一全局Id生成\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-11T14:10:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[{"level":3,"title":"为什么需要分布式全局唯一ID以及分布式ID的业务需求","slug":"为什么需要分布式全局唯一id以及分布式id的业务需求","link":"#为什么需要分布式全局唯一id以及分布式id的业务需求","children":[]},{"level":3,"title":"ID生成规则部分硬性要求","slug":"id生成规则部分硬性要求","link":"#id生成规则部分硬性要求","children":[]},{"level":3,"title":"ID号生成系统的可用性要求","slug":"id号生成系统的可用性要求","link":"#id号生成系统的可用性要求","children":[]}]},{"level":2,"title":"一般通用解决方案","slug":"一般通用解决方案","link":"#一般通用解决方案","children":[{"level":3,"title":"UUID","slug":"uuid","link":"#uuid","children":[]},{"level":3,"title":"数据库自增主键","slug":"数据库自增主键","link":"#数据库自增主键","children":[]},{"level":3,"title":"基于Redis生成全局ID策略","slug":"基于redis生成全局id策略","link":"#基于redis生成全局id策略","children":[]}]},{"level":2,"title":"雪花算法","slug":"雪花算法","link":"#雪花算法","children":[{"level":3,"title":"是什么","slug":"是什么","link":"#是什么","children":[]},{"level":3,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":3,"title":"实现","slug":"实现","link":"#实现","children":[]},{"level":3,"title":"工程落地经验","slug":"工程落地经验","link":"#工程落地经验","children":[]},{"level":3,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]}]}],"git":{"createdTime":1722090295000,"updatedTime":1723385410000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":2}]},"readingTime":{"minutes":11.05,"words":3314},"filePathRelative":"study-notes/shangguigu-three/UUID/README.md","localizedDate":"2023年3月11日","excerpt":"<h2>问题</h2>\\n<h3>为什么需要分布式全局唯一ID以及分布式ID的业务需求</h3>\\n<p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识，如在美团点评的金融、支付、餐饮、酒店</p>\\n<p>猫眼电影等产品的系统中数据逐渐增长，对数据库分库分表后需要有一个唯一ID来标识一条数据或信息；</p>\\n<p>特别Ian的订单、骑手、优惠券都需要有唯一ID做标识</p>\\n<p>此时一个能够生成全局唯一ID的系统是非常必要的</p>\\n<figure><figcaption>image-20200418080900190</figcaption></figure>\\n<h3>ID生成规则部分硬性要求</h3>","autoDesc":true}')}}]);