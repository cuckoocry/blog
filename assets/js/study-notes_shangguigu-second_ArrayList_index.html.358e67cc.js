"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[3894],{66262:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,n]of i)a[s]=n;return a}},75892:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>g,data:()=>k});var n=a(20641);const e=a.p+"assets/img/image-20200312202720715.1114797b.png",l=a.p+"assets/img/image-20200312205142763.736bf8c9.png",t=a.p+"assets/img/img.0c527a70.png",p=a.p+"assets/img/image-20200312210401865.99e79eda.png",r=a.p+"assets/img/image-20200312221602095.2fef8a12.png",d=a.p+"assets/img/image-20200312221735178.ce70d385.png",h=(0,n.Fv)('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>1、当我们执行下面语句的时候，底层进行了什么操作</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>new ArrayList&lt;Integer&gt;();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>底层创建了一个空的数组，伴随着初始值为10</p><p>当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Arrays.copyOf(elementData, netCapacity)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="单线程环境下" tabindex="-1"><a class="header-anchor" href="#单线程环境下"><span>单线程环境下</span></a></h2><p>单线程环境的ArrayList是不会有问题的</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class ArrayListNotSafeDemo {</span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span>\n<span class="line"><span>        list.add(&quot;a&quot;);</span></span>\n<span class="line"><span>        list.add(&quot;b&quot;);</span></span>\n<span class="line"><span>        list.add(&quot;c&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        for(String element : list) {</span></span>\n<span class="line"><span>            System.out.println(element);</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="多线程环境" tabindex="-1"><a class="header-anchor" href="#多线程环境"><span>多线程环境</span></a></h2><p>为什么ArrayList是线程不安全的？因为在进行写操作的时候，方法上为了保证并发性，是没有添加synchronized修饰，所以并发写的时候，就会出现问题</p><figure><img src="'+e+'" alt="image-20200312202720715" tabindex="0" loading="lazy"><figcaption>image-20200312202720715</figcaption></figure><p>当我们同时启动30个线程去操作List的时候</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 集合类线程不安全举例</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-12-20:15</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>public class ArrayListNotSafeDemo {</span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 30; i++) {</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                list.add(UUID.randomUUID().toString().substring(0, 8));</span></span>\n<span class="line"><span>                System.out.println(list);</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',14),c=(0,n.Fv)('<figure><img src="'+l+'" alt="image-20200312205142763" tabindex="0" loading="lazy"><figcaption>image-20200312205142763</figcaption></figure><p>这个异常是 并发修改的异常。</p><blockquote><p>1、故障现象<br> 2、导致原因<br> 3、解决方案<br> 4、优化建议（同样的错误不犯第二次）<br><img src="'+t+'" alt="img.png" loading="lazy"></p></blockquote><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h2><h3 id="方案一-vector" tabindex="-1"><a class="header-anchor" href="#方案一-vector"><span>方案一：Vector</span></a></h3><p>第一种方法，就是不用ArrayList这种不安全的List实现类，而采用Vector，线程安全的</p><p>关于Vector如何实现线程安全的，而是在方法上加了锁，即synchronized</p><figure><img src="'+p+'" alt="image-20200312210401865" tabindex="0" loading="lazy"><figcaption>image-20200312210401865</figcaption></figure><p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致并发性基于下降</p><h3 id="方案二-collections-synchronized" tabindex="-1"><a class="header-anchor" href="#方案二-collections-synchronized"><span>方案二：Collections.synchronized()</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>采用Collections集合工具类，在ArrayList外面包装一层 同步 机制</p><h3 id="方案三-采用juc里面的方法" tabindex="-1"><a class="header-anchor" href="#方案三-采用juc里面的方法"><span>方案三：采用JUC里面的方法</span></a></h3><p>CopyOnWriteArrayList：写时复制，主要是一种读写分离的思想</p><p>写时复制，CopyOnWrite容器即写时复制的容器，往一个容器中添加元素的时候，不直接往当前容器Object[]添加，而是先将Object[]进行copy，复制出一个新的容器object[] newElements，然后新的容器Object[] newElements里添加原始，添加元素完后，在将原容器的引用指向新的容器 setArray(newElements)；这样做的好处是可以对copyOnWrite容器进行并发的读 ，而不需要加锁，因为当前容器不需要添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p><p>就是写的时候，把ArrayList扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList的引用指向扩容后的</p><p>查看底层add方法源码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public boolean add(E e) {</span></span>\n<span class="line"><span>        final ReentrantLock lock = this.lock;</span></span>\n<span class="line"><span>        lock.lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            Object[] elements = getArray();</span></span>\n<span class="line"><span>            int len = elements.length;</span></span>\n<span class="line"><span>            Object[] newElements = Arrays.copyOf(elements, len + 1);</span></span>\n<span class="line"><span>            newElements[len] = e;</span></span>\n<span class="line"><span>            setArray(newElements);</span></span>\n<span class="line"><span>            return true;</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            lock.unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先需要加锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>final ReentrantLock lock = this.lock;</span></span>\n<span class="line"><span>lock.lock();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在末尾扩容一个单位</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Object[] elements = getArray();</span></span>\n<span class="line"><span>int len = elements.length;</span></span>\n<span class="line"><span>Object[] newElements = Arrays.copyOf(elements, len + 1);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在把扩容后的空间，填写上需要add的内容</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>newElements[len] = e;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>最后把内容set到Array中</p><h2 id="hashset线程不安全" tabindex="-1"><a class="header-anchor" href="#hashset线程不安全"><span>HashSet线程不安全</span></a></h2><h3 id="copyonwritearrayset" tabindex="-1"><a class="header-anchor" href="#copyonwritearrayset"><span>CopyOnWriteArraySet</span></a></h3><p>底层还是使用CopyOnWriteArrayList进行实例化</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    /**</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     * Creates an empty set.</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     */</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> CopyOnWriteArraySet</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        al </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CopyOnWriteArrayList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">E</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+r+'" alt="image-20200312221602095" tabindex="0" loading="lazy"><figcaption>image-20200312221602095</figcaption></figure><h3 id="hashset底层结构" tabindex="-1"><a class="header-anchor" href="#hashset底层结构"><span>HashSet底层结构</span></a></h3><p>同理HashSet的底层结构就是HashMap</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    /**</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     * default initial capacity (16) and load factor (0.75).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">     */</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> HashSet</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        map </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+d+'" alt="image-20200312221735178" tabindex="0" loading="lazy"><figcaption>image-20200312221735178</figcaption></figure><p>但是为什么我调用 HashSet.add()的方法，只需要传递一个元素，而HashMap是需要传递key-value键值对？</p><p>首先我们查看hashSet的add方法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public boolean add(E e) {</span></span>\n<span class="line"><span>        return map.put(e, PRESENT)==null;</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们能发现但我们调用add的时候，存储一个值进入map中，只是作为key进行存储，而value存储的是一个Object类型的常量，也就是说HashSet只关心key，而不关心value</p><h2 id="hashmap线程不安全" tabindex="-1"><a class="header-anchor" href="#hashmap线程不安全"><span>HashMap线程不安全</span></a></h2><p>同理HashMap在多线程环境下，也是不安全的</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 30; i++) {</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));</span></span>\n<span class="line"><span>                System.out.println(map);</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法"><span>解决方法</span></a></h3><p>1、使用Collections.synchronizedMap(new HashMap&lt;&gt;());</p><p>2、使用 ConcurrentHashMap</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h4><p>https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html</p>',47),o={},g=(0,a(66262).A)(o,[["render",function(s,i){const a=(0,n.g2)("font");return(0,n.uX)(),(0,n.CE)("div",null,[h,(0,n.Lk)("p",null,[(0,n.eW)("这个时候出现了错误，也就是"),(0,n.bF)(a,{color:"red"},{default:(0,n.k6)((()=>[(0,n.eW)("java.util.ConcurrentModificationException")])),_:1}),(0,n.eW)("（并发修改异常）")]),c])}]]),k=JSON.parse('{"path":"/study-notes/shangguigu-second/ArrayList/","title":"4、Collection线程不安全的举例","lang":"zh-CN","frontmatter":{"title":"4、Collection线程不安全的举例","date":"2023-03-11T00:00:00.000Z","tags":["JUC","Volatile"],"description":"前言 1、当我们执行下面语句的时候，底层进行了什么操作 底层创建了一个空的数组，伴随着初始值为10 当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容 单线程环境下 单线程环境的ArrayList是不会有问题的 多线程环境 为什么ArrayList是线程不安全的？因为在进行写操作的时候，方法上为了保...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/vuepress-theme-home/study-notes/shangguigu-second/ArrayList/"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"4、Collection线程不安全的举例"}],["meta",{"property":"og:description","content":"前言 1、当我们执行下面语句的时候，底层进行了什么操作 底层创建了一个空的数组，伴随着初始值为10 当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容 单线程环境下 单线程环境的ArrayList是不会有问题的 多线程环境 为什么ArrayList是线程不安全的？因为在进行写操作的时候，方法上为了保..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-11T14:10:10.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:tag","content":"Volatile"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-11T14:10:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4、Collection线程不安全的举例\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-11T14:10:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"单线程环境下","slug":"单线程环境下","link":"#单线程环境下","children":[]},{"level":2,"title":"多线程环境","slug":"多线程环境","link":"#多线程环境","children":[]},{"level":2,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[{"level":3,"title":"方案一：Vector","slug":"方案一-vector","link":"#方案一-vector","children":[]},{"level":3,"title":"方案二：Collections.synchronized()","slug":"方案二-collections-synchronized","link":"#方案二-collections-synchronized","children":[]},{"level":3,"title":"方案三：采用JUC里面的方法","slug":"方案三-采用juc里面的方法","link":"#方案三-采用juc里面的方法","children":[]}]},{"level":2,"title":"HashSet线程不安全","slug":"hashset线程不安全","link":"#hashset线程不安全","children":[{"level":3,"title":"CopyOnWriteArraySet","slug":"copyonwritearrayset","link":"#copyonwritearrayset","children":[]},{"level":3,"title":"HashSet底层结构","slug":"hashset底层结构","link":"#hashset底层结构","children":[]}]},{"level":2,"title":"HashMap线程不安全","slug":"hashmap线程不安全","link":"#hashmap线程不安全","children":[{"level":3,"title":"解决方法","slug":"解决方法","link":"#解决方法","children":[]}]}],"git":{"createdTime":1722089104000,"updatedTime":1723385410000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":2}]},"readingTime":{"minutes":3.73,"words":1119},"filePathRelative":"study-notes/shangguigu-second/ArrayList/README.md","localizedDate":"2023年3月11日","excerpt":"<h2>前言</h2>\\n<p>1、当我们执行下面语句的时候，底层进行了什么操作</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>new ArrayList&lt;Integer&gt;();</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);