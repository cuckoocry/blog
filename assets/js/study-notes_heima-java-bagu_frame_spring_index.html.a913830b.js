"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[2322],{66262:(i,e)=>{e.A=(i,e)=>{const t=i.__vccOpts||i;for(const[i,n]of e)t[i]=n;return t}},7362:(i,e,t)=>{t.r(e),t.d(e,{comp:()=>C,data:()=>E});var n=t(20641);const a=t.p+"assets/img/img_2.d50f2ac9.png",s=t.p+"assets/img/img_1.5ed3d8a2.png",l=t.p+"assets/img/img_3.dc5d4e34.png",r=t.p+"assets/img/img_4.9cbdb5ac.png",p=t.p+"assets/img/img_5.4aa87d56.png",g=t.p+"assets/img/img_6.193e3de7.png",o=t.p+"assets/img/img_7.a2754c7a.png",d=t.p+"assets/img/img_8.5430b722.png",c=t.p+"assets/img/img_9.2878c957.png",h=t.p+"assets/img/img_11.9d4ebc32.png",m=t.p+"assets/img/img_10.0c169dcc.png",b=t.p+"assets/img/img_14.9c423ca9.png",k=t.p+"assets/img/img_13.c79b950e.png",u=t.p+"assets/img/img_12.efba547f.png",y=t.p+"assets/img/img_15.a3c1d54e.png",f=t.p+"assets/img/img_16.556ceabf.png",A=t.p+"assets/img/img_17.db451dce.png",_=t.p+"assets/img/img_18.da20fb7b.png",v=t.p+"assets/img/img_19.88160d65.png",S=t.p+"assets/img/img_20.7f353fc6.png",B=[(0,n.Fv)('<div class="hint-container tip"><p class="hint-container-title">提示</p><p>视频来源：<a href="https://www.bilibili.com/video/BV1yT411H7YK/?vd_source=7138dfc78c49f602f8d3ed8cfbf0513d" target="_blank" rel="noopener noreferrer">新版Java面试专题视频教程，java八股文面试全套真题+深度详解（含大厂高频面试真题）</a></p></div><h3 id="_1、spring框架中的单例-bean是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#_1、spring框架中的单例-bean是线程安全的吗"><span>1、Spring框架中的单例 bean是线程安全的吗？</span></a></h3><p><strong>不是线程安全的。</strong></p><p>Spring框架中的单例 bean 是单例的:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Service</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 默认就是单例的</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Scope</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;singleton&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserServiceImpl</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>singleton</code>: bean在每个<code>Spring lOC</code>容器中只有一个实例。</li><li><code>prototype</code>: 一个bean的定义可以有多个实例。</li></ul><p>总结： 不是线程安全的 Spring框架中有一个<code>@Scope</code>注解，默认的值就是<code>singleton</code>。单例的。 因为一般在spring的bean的中都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决。</p><h3 id="_2、什么是aop-你们项目中有没有使用到aop" tabindex="-1"><a class="header-anchor" href="#_2、什么是aop-你们项目中有没有使用到aop"><span>2、什么是AOP？你们项目中有没有使用到AOP？</span></a></h3><p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面” (Aspect)，减少系统中的重复代码，降低了模块间的合度，同时提高了系统的可维护性。</p><p>常见的AOP使用场景：</p><ul><li>记录操作日志</li><li>缓存处理</li><li>Spring中内置的业务处理</li></ul><p>记录操作日志的思路：</p><blockquote><p>可以参考若依项目：LogAspect.java</p></blockquote><p>Spring中的事务是如何实现的？</p><p>Spring支持<strong>编程式事务</strong>管理和<strong>声明式事务</strong>管理两种方式</p><ul><li>编程式事务控制:需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li><li>声明式事务管理:声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li></ul><p>总结：</p><ol><li>什么是AOP？</li></ol><p>面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合。</p><ol start="2"><li>项目中有没有使用到AOP？</li></ol><p>记录操作日志，缓存，spring实现的事务 核心是:使用aop中的环绕通知+切点表达式(找到要记录日志的方法)，通过环绕通知的参数获取请求方法的参数(类、方法、注解、请求方式等)，获取到这些参数以后，保存到数据库</p><p>具体实现步骤：具体代码参考若依项目操作日志的实现。</p><ol><li><p>定义一个操作日志切面类。【LogAspect】</p></li><li><p>定义一个注解。【<code>public @interface Log</code>】</p></li><li><p>使用。</p></li><li><p>Spring中事务是如何实现的？</p></li></ol><p>其本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><h3 id="_2、spring中事务失效的场景有哪些-【对-spring框架的深入理解、复杂业务的编码经验】" tabindex="-1"><a class="header-anchor" href="#_2、spring中事务失效的场景有哪些-【对-spring框架的深入理解、复杂业务的编码经验】"><span>2、Spring中事务失效的场景有哪些？【对 Spring框架的深入理解、复杂业务的编码经验】</span></a></h3><ul><li>异常捕获处理</li></ul><figure><img src="'+a+'" alt="img_2.png" tabindex="0" loading="lazy"><figcaption>img_2.png</figcaption></figure><ul><li>抛出检查异常</li></ul><figure><img src="'+s+'" alt="img_1.png" tabindex="0" loading="lazy"><figcaption>img_1.png</figcaption></figure><ul><li>非public方法</li></ul><figure><img src="'+l+'" alt="img_3.png" tabindex="0" loading="lazy"><figcaption>img_3.png</figcaption></figure><p>总结：Spring中事务失效的场景有哪些？</p><ol><li>异常捕获处理，自己处理了异常，没有抛出，解决:手动抛出。</li><li>抛出检查异常，配置<code>rollbackFor</code>属性为<code>Exception</code>。</li><li>非<code>public</code>方法导致的事务失效，改为public。</li></ol><h3 id="_3、spring-的-bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#_3、spring-的-bean-的生命周期"><span>3、Spring 的 Bean 的生命周期</span></a></h3><ol><li><code>BeanDefinition</code>概念 Spring 容器在进行实例化时，会将 xml 配置的 <code>&lt;bean&gt;</code> 的信息封装成一个 <code>BeanDefinition</code> 对象， Spring 根据 BeanDefinition 来创建 Bean 对象，里面有很多的属性用来描述 Bean。</li></ol><figure><img src="'+r+'" alt="img_4.png" tabindex="0" loading="lazy"><figcaption>img_4.png</figcaption></figure><ol start="2"><li>bean的生命周期流程图</li></ol><figure><img src="'+p+'" alt="img_5.png" tabindex="0" loading="lazy"><figcaption>img_5.png</figcaption></figure><p>总结：Spring 的 Bean 的生命周期。</p><p>① 通过 BeanDefinition 获取 bean 的定义信息 ② 调用构造函数实例化 bean ③ bean 的依赖注入 ④ 处理 Aware 接口 (BeanNameAware 、 BeanFactoryAware 、 ApplicationContextAware) ⑤ Bean 的后置处理器 BeanPostProcessor- 前置 ⑥ 初始化方法 (InitializingBean 、 init-method) ⑦ Bean 的后置处理器 BeanPostProcessor- 后置 ⑧ 销毁 bean</p><figure><img src="'+g+'" alt="img_6.png" tabindex="0" loading="lazy"><figcaption>img_6.png</figcaption></figure><h3 id="_4、spring中的循环引用" tabindex="-1"><a class="header-anchor" href="#_4、spring中的循环引用"><span>4、Spring中的循环引用</span></a></h3><ol><li>什么是循环引用</li></ol><p><img src="'+o+'" alt="img_7.png" loading="lazy"><img src="'+d+'" alt="img_8.png" loading="lazy"></p><ol start="2"><li>Spring中<strong>三级缓存</strong>解决循环依赖</li></ol><p>三级缓存概念 <img src="'+c+'" alt="img_9.png" loading="lazy"></p><p>一级缓存：</p><figure><img src="'+h+'" alt="img_11.png" tabindex="0" loading="lazy"><figcaption>img_11.png</figcaption></figure><p>二级缓存：</p><figure><img src="'+m+'" alt="img_10.png" tabindex="0" loading="lazy"><figcaption>img_10.png</figcaption></figure><p>三级缓存：（解决了大部分循环依赖）</p><figure><img src="'+b+'" alt="img_14.png" tabindex="0" loading="lazy"><figcaption>img_14.png</figcaption></figure><ol start="3"><li>构造方法出现了循环依赖怎么解决？</li></ol><figure><img src="'+k+'" alt="img_13.png" tabindex="0" loading="lazy"><figcaption>img_13.png</figcaption></figure><p>总结：</p><ol><li>Spring中<strong>三级缓存</strong>解决循环依赖</li></ol><ul><li>循环依赖：循环依赖其实就是循环引用 , 也就是两个或两个以上的 bean 互相持有对方 , 最终形成闭环。比如 A 依赖于 B,B 依赖于 A。</li><li>循环依赖在 spring 中是允许存在， spring 框架依据三级缓存已经解决了大部分的循环依赖。</li></ul><p>① 一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的 bean 对象。 ② 二级缓存：缓存早期的 bean 对象（生命周期还没走完）。 ③ 三级缓存：缓存的是 <code>ObjectFactory</code> ，表示对象工厂，用来创建某个对象的。</p><figure><img src="'+b+'" alt="img_14.png" tabindex="0" loading="lazy"><figcaption>img_14.png</figcaption></figure><ol start="2"><li>构造方法出现了循环依赖怎么解决？</li></ol><p>问题：A 依赖于 B ， B 依赖于 A ，注入的方式是构造函数。</p><p><strong>原因</strong>：由于 bean 的生命周期中构造函数是第一个执行的， spring 框架并不能解决构造函数的依赖注入。 <strong>解决方案</strong>：使用 <code>@Lazy</code> 进行懒加载，什么时候需要对象再进行 bean 对象的创建。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Lazy</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> B</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b) {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;A 的构造方法执行了 ...&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4、springmvc-的执行流程知道嘛" tabindex="-1"><a class="header-anchor" href="#_4、springmvc-的执行流程知道嘛"><span>4、SpringMVC 的执行流程知道嘛？</span></a></h3><ol><li>视图阶段(JSP)</li></ol><figure><img src="'+u+'" alt="img_12.png" tabindex="0" loading="lazy"><figcaption>img_12.png</figcaption></figure><ol start="2"><li>前后端分离阶段（接口开发，异步请求）</li></ol><figure><img src="'+y+'" alt="img_15.png" tabindex="0" loading="lazy"><figcaption>img_15.png</figcaption></figure><p>总结：SpringMVC 的执行流程知道嘛？</p><p>（版本1：视图版本，JSP）</p><p>① 用户发送出请求到前端控制器 DispatcherServlet ② DispatcherServlet 收到请求调用 HandlerMapping （处理器映射器） ③ HandlerMapping 找到具体的处理器，生成处理器对象及处理器拦截器 ( 如果有 ) ，再一起返回给 DispatcherServlet 。 ④ DispatcherServlet 调用 HandlerAdapter （处理器适配器） ⑤ HandlerAdapter 经过适配调用具体的处理器（ Handler/Controller ） ⑥ Controller 执行完成返回 ModelAndView 对象 ⑦ HandlerAdapter 将 Controller 执行结果 ModelAndView 返回给 DispatcherServlet ⑧ DispatcherServlet 将 ModelAndView 传给 ViewReslover （视图解析器） ⑨ ViewReslover 解析后返回具体 View （视图） ⑩ DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中） ⑪ DispatcherServlet 响应用户</p><p>（版本2：前后端开发，接口开发）</p><p>① 用户发送出请求到前端控制器 DispatcherServlet ② DispatcherServlet 收到请求调用 HandlerMapping （处理器映射器） ③ HandlerMapping 找到具体的处理器，生成处理器对象及处理器拦截器 ( 如果有 ) ，再一起返回给 DispatcherServlet 。 ④ DispatcherServlet 调用 HandlerAdapter （处理器适配器） ⑤ HandlerAdapter 经过适配调用具体的处理器（ Handler/Controller ） ⑥ 方法上添加了 @ResponseBody ⑦ 通过 <code>HttpMessageConverter</code> 来返回结果转换为 JSON 并响应</p><h3 id="_5、springboot-自动配置原理" tabindex="-1"><a class="header-anchor" href="#_5、springboot-自动配置原理"><span>5、<strong>Springboot 自动配置原理？</strong></span></a></h3><p><strong>Springboot 中最高频的一道面试题，也是框架最核心的思想。</strong></p><p>先看段代码：</p><figure><img src="'+f+'" alt="img_16.png" tabindex="0" loading="lazy"><figcaption>img_16.png</figcaption></figure><ul><li><code>@SpringBootConfiguration</code> ：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类。</li><li><code>@ComponentScan</code> ：组件扫描，默认扫描当前引导类所在包及其子包。</li><li><code>@EnableAutoConfiguration</code> ： SpringBoot 实现自动化配置的核心注解。</li></ul><p><code>@EnableAutoConfiguration</code>为核心。</p><figure><img src="'+A+'" alt="img_17.png" tabindex="0" loading="lazy"><figcaption>img_17.png</figcaption></figure><p>总结：Springboot 自动配置原理</p><ol><li>在 Spring Boot 项目中的引导类上有一个注解 <code>@SpringBootApplication</code> ，这个注解是对三个注解进行了封装，分别是：</li></ol><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><ol start="2"><li><p>其中 <code>@EnableAutoConfiguration</code> 是实现自动化配置的<strong>核心注解</strong>。 该注解通过 <code>@Import</code> 注解导入对应的配置选择器。 内部就是读取了该项目和该项目引用的 Jar 包的的 classpath 路径下 <code>META-INF/spring.factories</code> 文件中的所配置的类的全类名。 在这些配置类中所定义的 Bean 会根据条件注解<strong>所指定的条件来决定</strong>是否需要将其导入到 Spring 容器中。</p></li><li><p>条件判断会有像 <code>@ConditionalOnClass</code> 这样的注解，判断是否有对应的 class 文件，如果有则加载该类，把这个配置类的所有的 Bean 放入 spring 容器中使用。</p></li></ol><h3 id="_6、spring-框架常见注解-spring-、-springboot-、-springmvc" tabindex="-1"><a class="header-anchor" href="#_6、spring-框架常见注解-spring-、-springboot-、-springmvc"><span>6、Spring 框架常见注解（ Spring 、 Springboot 、 SpringMVC</span></a></h3><p>三个问题：</p><ul><li>Spring 的常见注解有哪些？</li><li>SpringMVC 常见的注解有哪些？</li><li>Springboot 常见注解有哪些？</li></ul><ol><li>Spring 的常见注解有哪些？</li></ol><figure><img src="'+_+'" alt="img_18.png" tabindex="0" loading="lazy"><figcaption>img_18.png</figcaption></figure><table><thead><tr><th style="text-align:center;"><strong>注解</strong></th><th style="text-align:center;"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:center;">@Component 、 @Controller 、 @Service 、 @Repository</td><td style="text-align:center;">使用在类上用于实例化 Bea</td></tr><tr><td style="text-align:center;">@Autowired</td><td style="text-align:center;">使用在字段上用于根据类型依赖注入</td></tr><tr><td style="text-align:center;">@Qualifier</td><td style="text-align:center;">结合 @Autowired 一起使用用于根据名称进行依赖注入</td></tr><tr><td style="text-align:center;">@Scope</td><td style="text-align:center;">标注 Bean 的作用范围</td></tr><tr><td style="text-align:center;">@Configuration</td><td style="text-align:center;">指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td></tr><tr><td style="text-align:center;">@ComponentScan</td><td style="text-align:center;">用于指定 Spring 在初始化容器时要扫描的包</td></tr><tr><td style="text-align:center;">@Bean</td><td style="text-align:center;">使用在方法上，标注将该方法的返回值存储到 Spring 容器中</td></tr><tr><td style="text-align:center;">@Import</td><td style="text-align:center;">使用 @Import 导入的类会被 Spring 加载到 IOC 容器中</td></tr><tr><td style="text-align:center;">@Aspect 、 @Before 、 @After 、 @Around 、 @Pointcut</td><td style="text-align:center;">用于切面编程（ AOP ）</td></tr></tbody></table><ol start="2"><li>SpringMVC 常见的注解有哪些？主要是请求和响应</li></ol><figure><img src="'+v+'" alt="img_19.png" tabindex="0" loading="lazy"><figcaption>img_19.png</figcaption></figure><table><thead><tr><th style="text-align:center;"><strong>注解</strong></th><th style="text-align:center;"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:center;">@RequestMapping</td><td style="text-align:center;">用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径</td></tr><tr><td style="text-align:center;">@RequestBody</td><td style="text-align:center;">注解实现接收 http 请求的 json 数据，将 json 转换为 java 对象</td></tr><tr><td style="text-align:center;">@RequestParam</td><td style="text-align:center;">指定请求参数的名称</td></tr><tr><td style="text-align:center;">@PathViriable</td><td style="text-align:center;">从请求路径下中获取请求参数 (/user/{id}) ，传递给方法的形式参数</td></tr><tr><td style="text-align:center;">@ResponseBody</td><td style="text-align:center;">注解实现将 controller 方法返回对象转化为 json 对象响应给客户端</td></tr><tr><td style="text-align:center;">@RequestHeader</td><td style="text-align:center;">获取指定的请求头数据</td></tr><tr><td style="text-align:center;">@RestController</td><td style="text-align:center;">@Controller + @ResponseBody</td></tr></tbody></table><ol start="3"><li>Springboot 常见注解有哪些？</li></ol><figure><img src="'+S+'" alt="img_20.png" tabindex="0" loading="lazy"><figcaption>img_20.png</figcaption></figure>',95)],x={},C=(0,t(66262).A)(x,[["render",function(i,e){return(0,n.uX)(),(0,n.CE)("div",null,B)}]]),E=JSON.parse('{"path":"/study-notes/heima-java-bagu/frame/spring/","title":"框架 - Spring","lang":"zh-CN","frontmatter":{"title":"框架 - Spring","category":"面试","description":"提示 视频来源：新版Java面试专题视频教程，java八股文面试全套真题+深度详解（含大厂高频面试真题） 1、Spring框架中的单例 bean是线程安全的吗？ 不是线程安全的。 Spring框架中的单例 bean 是单例的: singleton: bean在每个Spring lOC容器中只有一个实例。 prototype: 一个bean的定义可以有多...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/heima-java-bagu/frame/spring/"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"框架 - Spring"}],["meta",{"property":"og:description","content":"提示 视频来源：新版Java面试专题视频教程，java八股文面试全套真题+深度详解（含大厂高频面试真题） 1、Spring框架中的单例 bean是线程安全的吗？ 不是线程安全的。 Spring框架中的单例 bean 是单例的: singleton: bean在每个Spring lOC容器中只有一个实例。 prototype: 一个bean的定义可以有多..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:43:11.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:43:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"框架 - Spring\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-27T14:43:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"1、Spring框架中的单例 bean是线程安全的吗？","slug":"_1、spring框架中的单例-bean是线程安全的吗","link":"#_1、spring框架中的单例-bean是线程安全的吗","children":[]},{"level":3,"title":"2、什么是AOP？你们项目中有没有使用到AOP？","slug":"_2、什么是aop-你们项目中有没有使用到aop","link":"#_2、什么是aop-你们项目中有没有使用到aop","children":[]},{"level":3,"title":"2、Spring中事务失效的场景有哪些？【对 Spring框架的深入理解、复杂业务的编码经验】","slug":"_2、spring中事务失效的场景有哪些-【对-spring框架的深入理解、复杂业务的编码经验】","link":"#_2、spring中事务失效的场景有哪些-【对-spring框架的深入理解、复杂业务的编码经验】","children":[]},{"level":3,"title":"3、Spring 的 Bean 的生命周期","slug":"_3、spring-的-bean-的生命周期","link":"#_3、spring-的-bean-的生命周期","children":[]},{"level":3,"title":"4、Spring中的循环引用","slug":"_4、spring中的循环引用","link":"#_4、spring中的循环引用","children":[]},{"level":3,"title":"4、SpringMVC 的执行流程知道嘛？","slug":"_4、springmvc-的执行流程知道嘛","link":"#_4、springmvc-的执行流程知道嘛","children":[]},{"level":3,"title":"5、Springboot 自动配置原理？","slug":"_5、springboot-自动配置原理","link":"#_5、springboot-自动配置原理","children":[]},{"level":3,"title":"6、Spring 框架常见注解（ Spring 、 Springboot 、 SpringMVC","slug":"_6、spring-框架常见注解-spring-、-springboot-、-springmvc","link":"#_6、spring-框架常见注解-spring-、-springboot-、-springmvc","children":[]}],"git":{"createdTime":1722091391000,"updatedTime":1722091391000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":8.4,"words":2521},"filePathRelative":"study-notes/heima-java-bagu/frame/spring/README.md","localizedDate":"2024年7月27日","excerpt":"<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p>视频来源：<a href=\\"https://www.bilibili.com/video/BV1yT411H7YK/?vd_source=7138dfc78c49f602f8d3ed8cfbf0513d\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">新版Java面试专题视频教程，java八股文面试全套真题+深度详解（含大厂高频面试真题）</a></p>\\n</div>\\n<h3>1、Spring框架中的单例 bean是线程安全的吗？</h3>","autoDesc":true}')}}]);