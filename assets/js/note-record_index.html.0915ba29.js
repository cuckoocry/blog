"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[7123],{66262:(t,e)=>{e.A=(t,e)=>{const i=t.__vccOpts||t;for(const[t,n]of e)i[t]=n;return i}},31107:(t,e,i)=>{i.r(e),i.d(e,{comp:()=>p,data:()=>r});var n=i(20641);const o=[(0,n.Fv)('<p>笔记的总览。将学习的知识点总结和归纳。</p><ul><li><p>1、你们项目中有没有做过限流 ? 怎么做的 ? 漏铜算法、令牌桶</p></li><li><p>2、Redis 集群,中从复制等 数据同步：分布式锁，MQ异步通知、Canal（无代码嵌入） 集群方案： 主从复制：读写分离。（全量同步，增量同步）。保证不了高可用 哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知) 分片集群：解决海量数据，高并发。集群中有多个master，每个master保存不同数据。引入了哈希槽的概念</p><p>为什么快：内存操作，单线程、IO多路复用。性能瓶颈是网络延迟。监听多个Socket，避免无效等待。</p></li><li><p>3、消息中间件 保证不丢失：开启生产者确认机制、开启持久化功能、开启消费者确认机制为auto 重复消费问题:业务的唯一标识、（典型的幂等的问题）redis分布式锁、数据库的锁 消息堆积：:提高消费者的消费能力，使用多线程、增加消费者、扩大队列容积</p></li><li><p>4、微服务 注册中心、负载均衡、远程调用、服务熔断、网关</p><p>注册中心：服务注册 、服务发现、服务状态监控 Nacos与Eureka的区别：Nacos集群默认采用AP方式</p></li></ul><p>负载均衡如何实现的: Ribbon 组件实现，, Feign的底层已经自动集成了Ribbon。</p><p>Ribbon负载均衡策略:轮询、权重、随机、区域敏感</p><p>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形。 解决：第一个是服务降级，第二个是服务熔断，如果流量太大的话，可以考虑限流</p><p>分布式服务的接口幂等性如何设计：（保证重复调用的结果和单次调用的结果一致）。<code>token+redis</code></p><ul><li>JVM 程序计数器：完成分支、循环、跳转、异常处理、线程恢复 方法区：存储了每一个类的结构信息。包括：运行时常量池、字段</li></ul><h3 id="jvm监控及诊断工具-命令行篇" tabindex="-1"><a class="header-anchor" href="#jvm监控及诊断工具-命令行篇"><span>JVM监控及诊断工具-命令行篇</span></a></h3><p>补充：如果某 Java 进程关闭了默认开启的UsePerfData参数（即使用参数-XX：-UsePerfData），那么jps命令（以及下面介绍的jstat）将无法探知该Java 进程。</p><ul><li>jps：查看正在运行的Java进程</li><li>jstat：查看JVM统计信息。（用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据）</li><li>jinfo：实时查看和修改JVM配置参数。</li><li>jmap：导出内存映像文件&amp;内存使用情况</li><li>jhat：JDK自带堆分析工具。（hat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。） 使用了jhat命令，就启动了一个http服务，端口是7000，即http://localhost:7000/，就可以在浏览器里分析。</li><li></li></ul><p>MySQL 锁</p><p>当然，MySQL中的锁是数据库管理系统用来保证数据一致性和完整性的重要机制。以下是MySQL中常见的几种锁类型：</p><ol><li><strong>乐观锁（Optimistic Locking）</strong>：这种锁不是MySQL内置的，而是通过应用程序来实现。乐观锁假设多个事务并发访问同一数据时，不会发生冲突，因此在大多数情况下不会对数据进行锁定。它通常通过版本号或时间戳来实现。</li><li><strong>悲观锁（Pessimistic Locking）</strong>：与乐观锁相反，悲观锁假设多个事务并发访问同一数据时会发生冲突，因此在数据被访问时就进行锁定。 以下是MySQL中具体的锁类型：</li><li><strong>表锁（Table Lock）</strong>： <ul><li><strong>共享锁（Shared Lock）</strong>：多个事务可以同时获取同一张表的共享锁，用于读取操作。</li><li><strong>排他锁（Exclusive Lock）</strong>：在事务对表进行写操作时使用，确保同一时间只有一个事务能对表进行写操作。</li></ul></li><li><strong>行锁（Row Lock）</strong>： <ul><li><strong>记录锁（Record Lock）</strong>：锁定特定的记录行。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，但不包括记录本身，用于防止幻读。</li><li><strong>临键锁（Next-Key Lock）</strong>：是记录锁和间隙锁的组合，锁定一个范围，并且包括记录本身。</li></ul></li><li><strong>意向锁（Intention Lock）</strong>： <ul><li><strong>意向共享锁（Intention Shared Lock）</strong>：表示事务打算在表中的某些行上设置共享锁。</li><li><strong>意向排他锁（Intention Exclusive Lock）</strong>：表示事务打算在表中的某些行上设置排他锁。</li></ul></li><li><strong>自增锁（AUTO-INC Lock）</strong>：在插入数据时，为了保持自增字段的连续性，MySQL会对表施加自增锁。 锁的粒度不同，对性能的影响也不同。表锁的开销较小，但并发性能较差；行锁的开销较大，但并发性能较好。在实际使用中，应根据具体场景选择合适的锁策略。</li></ol><p>排查问题</p><p>MQ高并发</p><p>AOP spring加在Bean 三级缓存</p><p>1、现场环境查看JVM运行情况 2、快速排序 3、JVM调优 4、现场遇到的问题排查</p>',17)],l={},p=(0,i(66262).A)(l,[["render",function(t,e){return(0,n.uX)(),(0,n.CE)("div",null,o)}]]),r=JSON.parse('{"path":"/note-record/","title":"学习笔记总结","lang":"zh-CN","frontmatter":{"title":"学习笔记总结","category":"学习笔记","description":"笔记的总览。将学习的知识点总结和归纳。 1、你们项目中有没有做过限流 ? 怎么做的 ? 漏铜算法、令牌桶 2、Redis 集群,中从复制等 数据同步：分布式锁，MQ异步通知、Canal（无代码嵌入） 集群方案： 主从复制：读写分离。（全量同步，增量同步）。保证不了高可用 哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知) 分片集群：解决海...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/note-record/"}],["meta",{"property":"og:site_name","content":"撄宁的博客"}],["meta",{"property":"og:title","content":"学习笔记总结"}],["meta",{"property":"og:description","content":"笔记的总览。将学习的知识点总结和归纳。 1、你们项目中有没有做过限流 ? 怎么做的 ? 漏铜算法、令牌桶 2、Redis 集群,中从复制等 数据同步：分布式锁，MQ异步通知、Canal（无代码嵌入） 集群方案： 主从复制：读写分离。（全量同步，增量同步）。保证不了高可用 哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知) 分片集群：解决海..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-11T13:11:23.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:modified_time","content":"2024-08-11T13:11:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"学习笔记总结\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-11T13:11:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"JVM监控及诊断工具-命令行篇","slug":"jvm监控及诊断工具-命令行篇","link":"#jvm监控及诊断工具-命令行篇","children":[]}],"git":{"createdTime":1722093117000,"updatedTime":1723381883000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":7}]},"readingTime":{"minutes":4.41,"words":1322},"filePathRelative":"note-record/README.md","localizedDate":"2024年7月27日","excerpt":"<p>笔记的总览。将学习的知识点总结和归纳。</p>\\n<ul>\\n<li>\\n<p>1、你们项目中有没有做过限流 ? 怎么做的 ?\\n漏铜算法、令牌桶</p>\\n</li>\\n<li>\\n<p>2、Redis 集群,中从复制等\\n数据同步：分布式锁，MQ异步通知、Canal（无代码嵌入）\\n集群方案：\\n主从复制：读写分离。（全量同步，增量同步）。保证不了高可用\\n哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知)\\n分片集群：解决海量数据，高并发。集群中有多个master，每个master保存不同数据。引入了哈希槽的概念</p>\\n<p>为什么快：内存操作，单线程、IO多路复用。性能瓶颈是网络延迟。监听多个Socket，避免无效等待。</p>\\n</li>\\n<li>\\n<p>3、消息中间件\\n保证不丢失：开启生产者确认机制、开启持久化功能、开启消费者确认机制为auto\\n重复消费问题:业务的唯一标识、（典型的幂等的问题）redis分布式锁、数据库的锁\\n消息堆积：:提高消费者的消费能力，使用多线程、增加消费者、扩大队列容积</p>\\n</li>\\n<li>\\n<p>4、微服务\\n注册中心、负载均衡、远程调用、服务熔断、网关</p>\\n<p>注册中心：服务注册 、服务发现、服务状态监控\\nNacos与Eureka的区别：Nacos集群默认采用AP方式</p>\\n</li>\\n</ul>","autoDesc":true}')}}]);