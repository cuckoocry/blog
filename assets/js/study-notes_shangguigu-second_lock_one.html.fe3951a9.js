"use strict";(self.webpackChunkblogs2=self.webpackChunkblogs2||[]).push([[7174],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}},62126:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>p,data:()=>c});var i=a(20641);const e=[(0,i.Fv)('<h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p><strong>独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁。</strong></p><p>共享锁：指该锁可以被多个线程锁持有</p><p>对ReentrantReadWriteLock其读锁是共享，其写锁是独占</p><p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p><h2 id="为什么会有写锁和读锁" tabindex="-1"><a class="header-anchor" href="#为什么会有写锁和读锁"><span>为什么会有写锁和读锁</span></a></h2><p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读</p><blockquote><p>多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</p></blockquote><p>读-读：能共存</p><p>读-写：不能共存</p><p>写-写：不能共存</p><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h2><p>实现一个读写缓存的操作，假设开始没有加锁的时候，会出现什么情况</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 读写锁</span></span>\n<span class="line"><span> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。</span></span>\n<span class="line"><span> * 但是，</span></span>\n<span class="line"><span> * 如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span></span>\n<span class="line"><span> * 小总结：</span></span>\n<span class="line"><span> *       读-读：能共存</span></span>\n<span class="line"><span> *       读-写：不能共存</span></span>\n<span class="line"><span> *      写-写：不能共存</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2020-03-01</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>import java.util.HashMap;</span></span>\n<span class="line"><span>import java.util.Map;</span></span>\n<span class="line"><span>import java.util.concurrent.TimeUnit;</span></span>\n<span class="line"><span>import java.util.concurrent.locks.Lock;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span> * 资源类</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>class MyCache {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span></span>\n<span class="line"><span>    // private Lock lock = null;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 定义写操作</span></span>\n<span class="line"><span>     * 满足：原子 + 独占</span></span>\n<span class="line"><span>     * @param key</span></span>\n<span class="line"><span>     * @param value</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public void put(String key, Object value) {</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t 正在写入：&quot; + key);</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 模拟网络拥堵，延迟0.3秒</span></span>\n<span class="line"><span>            TimeUnit.MILLISECONDS.sleep(300);</span></span>\n<span class="line"><span>        } catch (InterruptedException e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        map.put(key, value);</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t 写入完成&quot;);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public void get(String key) {</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t 正在读取:&quot;);</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span>            // 模拟网络拥堵，延迟0.3秒</span></span>\n<span class="line"><span>            TimeUnit.MILLISECONDS.sleep(300);</span></span>\n<span class="line"><span>        } catch (InterruptedException e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        Object value = map.get(key);</span></span>\n<span class="line"><span>        System.out.println(Thread.currentThread().getName() + &quot;\\t 读取完成：&quot; + value);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>public class ReadWriteLockDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        MyCache myCache = new MyCache();</span></span>\n<span class="line"><span>        // 线程操作资源类，5个线程写</span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 5; i++) {</span></span>\n<span class="line"><span>            // lambda表达式内部必须是final</span></span>\n<span class="line"><span>            final int tempInt = i;</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                myCache.put(tempInt + &quot;&quot;, tempInt +  &quot;&quot;);</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        // 线程操作资源类， 5个线程读</span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 5; i++) {</span></span>\n<span class="line"><span>            // lambda表达式内部必须是final</span></span>\n<span class="line"><span>            final int tempInt = i;</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                myCache.get(tempInt + &quot;&quot;);</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们分别创建5个线程写入缓存</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        // 线程操作资源类，5个线程写</span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 5; i++) {</span></span>\n<span class="line"><span>            // lambda表达式内部必须是final</span></span>\n<span class="line"><span>            final int tempInt = i;</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                myCache.put(tempInt + &quot;&quot;, tempInt +  &quot;&quot;);</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5个线程读取缓存，</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        // 线程操作资源类， 5个线程读</span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 5; i++) {</span></span>\n<span class="line"><span>            // lambda表达式内部必须是final</span></span>\n<span class="line"><span>            final int tempInt = i;</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                myCache.get(tempInt + &quot;&quot;);</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后运行结果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>0\t 正在写入：0</span></span>\n<span class="line"><span>4\t 正在写入：4</span></span>\n<span class="line"><span>3\t 正在写入：3</span></span>\n<span class="line"><span>1\t 正在写入：1</span></span>\n<span class="line"><span>2\t 正在写入：2</span></span>\n<span class="line"><span>0\t 正在读取:</span></span>\n<span class="line"><span>1\t 正在读取:</span></span>\n<span class="line"><span>2\t 正在读取:</span></span>\n<span class="line"><span>3\t 正在读取:</span></span>\n<span class="line"><span>4\t 正在读取:</span></span>\n<span class="line"><span>2\t 写入完成</span></span>\n<span class="line"><span>4\t 写入完成</span></span>\n<span class="line"><span>4\t 读取完成：null</span></span>\n<span class="line"><span>0\t 写入完成</span></span>\n<span class="line"><span>3\t 读取完成：null</span></span>\n<span class="line"><span>0\t 读取完成：null</span></span>\n<span class="line"><span>1\t 写入完成</span></span>\n<span class="line"><span>3\t 写入完成</span></span>\n<span class="line"><span>1\t 读取完成：null</span></span>\n<span class="line"><span>2\t 读取完成：null</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，在写入的时候，写操作都没完成就被其它线程打断了，这就造成了，还没写完，其它线程又开始写，这样就造成数据不一致</p><h2 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法"><span>解决方法</span></a></h2><p>上面的代码是没有加锁的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到读写锁来解决了</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span>* 创建一个读写锁</span></span>\n<span class="line"><span>* 它是一个读写融为一体的锁，在使用的时候，需要转换</span></span>\n<span class="line"><span>*/</span></span>\n<span class="line"><span>private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们在进行写操作的时候，就需要转换成写锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 创建一个写锁</span></span>\n<span class="line"><span>rwLock.writeLock().lock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 写锁 释放</span></span>\n<span class="line"><span>rwLock.writeLock().unlock();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当们在进行读操作的时候，在转换成读锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 创建一个读锁</span></span>\n<span class="line"><span>rwLock.readLock().lock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 读锁 释放</span></span>\n<span class="line"><span>rwLock.readLock().unlock();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的读锁和写锁的区别在于，写锁一次只能一个线程进入，执行写操作，而读锁是多个线程能够同时进入，进行读取的操作</p><p>完整代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>\n<span class="line"><span> * 读写锁</span></span>\n<span class="line"><span> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span></span>\n<span class="line"><span> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span></span>\n<span class="line"><span> *</span></span>\n<span class="line"><span> * @author: 阿飞</span></span>\n<span class="line"><span> * @create: 2023-03-01</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>import java.util.HashMap;</span></span>\n<span class="line"><span>import java.util.Map;</span></span>\n<span class="line"><span>import java.util.concurrent.TimeUnit;</span></span>\n<span class="line"><span>import java.util.concurrent.locks.Lock;</span></span>\n<span class="line"><span>import java.util.concurrent.locks.ReentrantLock;</span></span>\n<span class="line"><span>import java.util.concurrent.locks.ReentrantReadWriteLock;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/**</span></span>\n<span class="line"><span> * 资源类</span></span>\n<span class="line"><span> */</span></span>\n<span class="line"><span>class MyCache {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 创建一个读写锁</span></span>\n<span class="line"><span>     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 定义写操作</span></span>\n<span class="line"><span>     * 满足：原子 + 独占</span></span>\n<span class="line"><span>     * @param key</span></span>\n<span class="line"><span>     * @param value</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public void put(String key, Object value) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 创建一个写锁</span></span>\n<span class="line"><span>        rwLock.writeLock().lock();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t 正在写入：&quot; + key);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                // 模拟网络拥堵，延迟0.3秒</span></span>\n<span class="line"><span>                TimeUnit.MILLISECONDS.sleep(300);</span></span>\n<span class="line"><span>            } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            map.put(key, value);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t 写入完成&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            // 写锁 释放</span></span>\n<span class="line"><span>            rwLock.writeLock().unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 获取</span></span>\n<span class="line"><span>     * @param key</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public void get(String key) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 读锁</span></span>\n<span class="line"><span>        rwLock.readLock().lock();</span></span>\n<span class="line"><span>        try {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t 正在读取:&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            try {</span></span>\n<span class="line"><span>                // 模拟网络拥堵，延迟0.3秒</span></span>\n<span class="line"><span>                TimeUnit.MILLISECONDS.sleep(300);</span></span>\n<span class="line"><span>            } catch (InterruptedException e) {</span></span>\n<span class="line"><span>                e.printStackTrace();</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            Object value = map.get(key);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>            System.out.println(Thread.currentThread().getName() + &quot;\\t 读取完成：&quot; + value);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        } catch (Exception e) {</span></span>\n<span class="line"><span>            e.printStackTrace();</span></span>\n<span class="line"><span>        } finally {</span></span>\n<span class="line"><span>            // 读锁释放</span></span>\n<span class="line"><span>            rwLock.readLock().unlock();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    /**</span></span>\n<span class="line"><span>     * 清空缓存</span></span>\n<span class="line"><span>     */</span></span>\n<span class="line"><span>    public void clean() {</span></span>\n<span class="line"><span>        map.clear();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>public class ReadWriteLockDemo {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    public static void main(String[] args) {</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        MyCache myCache = new MyCache();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 线程操作资源类，5个线程写</span></span>\n<span class="line"><span>        for (int i = 1; i &lt;= 5; i++) {</span></span>\n<span class="line"><span>            // lambda表达式内部必须是final</span></span>\n<span class="line"><span>            final int tempInt = i;</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                myCache.put(tempInt + &quot;&quot;, tempInt +  &quot;&quot;);</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        // 线程操作资源类， 5个线程读</span></span>\n<span class="line"><span>        for (int i = 1; i &lt;= 5; i++) {</span></span>\n<span class="line"><span>            // lambda表达式内部必须是final</span></span>\n<span class="line"><span>            final int tempInt = i;</span></span>\n<span class="line"><span>            new Thread(() -&gt; {</span></span>\n<span class="line"><span>                myCache.get(tempInt + &quot;&quot;);</span></span>\n<span class="line"><span>            }, String.valueOf(i)).start();</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1\t 正在写入：1</span></span>\n<span class="line"><span>1\t 写入完成</span></span>\n<span class="line"><span>2\t 正在写入：2</span></span>\n<span class="line"><span>2\t 写入完成</span></span>\n<span class="line"><span>3\t 正在写入：3</span></span>\n<span class="line"><span>3\t 写入完成</span></span>\n<span class="line"><span>4\t 正在写入：4</span></span>\n<span class="line"><span>4\t 写入完成</span></span>\n<span class="line"><span>5\t 正在写入：5</span></span>\n<span class="line"><span>5\t 写入完成</span></span>\n<span class="line"><span>2\t 正在读取:</span></span>\n<span class="line"><span>3\t 正在读取:</span></span>\n<span class="line"><span>1\t 正在读取:</span></span>\n<span class="line"><span>4\t 正在读取:</span></span>\n<span class="line"><span>5\t 正在读取:</span></span>\n<span class="line"><span>2\t 读取完成：2</span></span>\n<span class="line"><span>1\t 读取完成：1</span></span>\n<span class="line"><span>4\t 读取完成：4</span></span>\n<span class="line"><span>3\t 读取完成：3</span></span>\n<span class="line"><span>5\t 读取完成：5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从运行结果我们可以看出，写入操作是一个一个线程进行执行的，并且中间不会被打断，而读操作的时候，是同时5个线程进入，然后并发读取操作</p>',34)],l={},p=(0,a(66262).A)(l,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,e)}]]),c=JSON.parse('{"path":"/study-notes/shangguigu-second/lock/one.html","title":"独占锁（写锁） / 共享锁（读锁） / 互斥锁","lang":"zh-CN","frontmatter":{"title":"独占锁（写锁） / 共享锁（读锁） / 互斥锁","date":"2023-03-18T00:00:00.000Z","tags":["锁"],"category":["学习笔记"],"dir":{"order":1},"description":"概念 独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁。 共享锁：指该锁可以被多个线程锁持有 对ReentrantReadWriteLock其读锁是共享，其写锁是独占 写的时候只能一个人写，但是读的时候，可以多个人同时读 为什么会有写锁和读锁 原来我们使用ReentrantLock创建锁的时候...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study-notes/shangguigu-second/lock/one.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"独占锁（写锁） / 共享锁（读锁） / 互斥锁"}],["meta",{"property":"og:description","content":"概念 独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁。 共享锁：指该锁可以被多个线程锁持有 对ReentrantReadWriteLock其读锁是共享，其写锁是独占 写的时候只能一个人写，但是读的时候，可以多个人同时读 为什么会有写锁和读锁 原来我们使用ReentrantLock创建锁的时候..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T14:05:04.000Z"}],["meta",{"property":"article:author","content":"樱宁"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:published_time","content":"2023-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T14:05:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"独占锁（写锁） / 共享锁（读锁） / 互斥锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T14:05:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"樱宁\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"为什么会有写锁和读锁","slug":"为什么会有写锁和读锁","link":"#为什么会有写锁和读锁","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]},{"level":2,"title":"解决方法","slug":"解决方法","link":"#解决方法","children":[]}],"git":{"createdTime":1722089104000,"updatedTime":1722089104000,"contributors":[{"name":"jiang","email":"948742327@qq.com","commits":1}]},"readingTime":{"minutes":6.01,"words":1802},"filePathRelative":"study-notes/shangguigu-second/lock/one.md","localizedDate":"2023年3月18日","excerpt":"<h2>概念</h2>\\n<p><strong>独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁。</strong></p>\\n<p>共享锁：指该锁可以被多个线程锁持有</p>\\n<p>对ReentrantReadWriteLock其读锁是共享，其写锁是独占</p>\\n<p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p>\\n<h2>为什么会有写锁和读锁</h2>\\n<p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读</p>","autoDesc":true}')}}]);