---
title: 学习笔记总结
category: 学习笔记

---


笔记的总览。将学习的知识点总结和归纳。



- 1、你们项目中有没有做过限流 ? 怎么做的 ?
    漏铜算法、令牌桶

- 2、Redis 集群,中从复制等
        数据同步：分布式锁，MQ异步通知、Canal（无代码嵌入）
        集群方案：
         主从复制：读写分离。（全量同步，增量同步）。保证不了高可用
         哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知)
         分片集群：解决海量数据，高并发。集群中有多个master，每个master保存不同数据。引入了哈希槽的概念

    为什么快：内存操作，单线程、IO多路复用。性能瓶颈是网络延迟。监听多个Socket，避免无效等待。
 
- 3、消息中间件
     保证不丢失：开启生产者确认机制、开启持久化功能、开启消费者确认机制为auto
     重复消费问题:业务的唯一标识、（典型的幂等的问题）redis分布式锁、数据库的锁。
     消息堆积：:提高消费者的消费能力，使用多线程、增加消费者、扩大队列容积。（消费者扩容）
     顺序消息分为全局顺序消息和部分顺序消息，全局顺序消息指某个 Topic 下的所有消息都要保证顺序；为了保证整个 Topic全局消息有序，只能消除所有的并发处理，各部分都设置成单线程处理 ，这时候就完全牺牲RocketMQ的高并发、高吞吐的特性了。

- 4、微服务
    注册中心、负载均衡、远程调用、服务熔断、网关

    注册中心：服务注册 、服务发现、服务状态监控
    Nacos与Eureka的区别：Nacos集群默认采用AP方式

负载均衡如何实现的: Ribbon 组件实现，, Feign的底层已经自动集成了Ribbon。

Ribbon负载均衡策略:轮询、权重、随机、区域敏感

服务雪崩：一个服务失败，导致整条链路的服务都失败的情形。
解决：第一个是服务降级，第二个是服务熔断，如果流量太大的话，可以考虑限流


分布式服务的接口幂等性如何设计：（保证重复调用的结果和单次调用的结果一致）。`token+redis`




- JVM 
  程序计数器：完成分支、循环、跳转、异常处理、线程恢复
  方法区：存储了每一个类的结构信息。包括：运行时常量池、字段
  


MySQL  锁

排查问题
  CPU  过高

   top 列出系统各个进程的资源占用情况。
   top -Hp 进程 ID 列出对应进程里面的线程占用资源情况
   printf "%x\n" PID 把线程 ID 转换为 16 进制。
   jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为 16 进制的线程 ID 对应的线程信息。
   最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。


MQ高并发

- RocketMQ
  发布-订阅模型   ，生产者、消费者和主题
  RocketMQ 一共有四个部分组成：NameServer(和Broker 结点保持长连接、维护 Topic 的路由信息)，Broker(消息存储和中转角色，负责存储和转发消息)，Producer 生产者，Consumer 消费者，它们对应了：发现、发、存、收，为了保证高可用，一般每一部分都是集群部署的。




- AOP  
  面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合。

- spring Bean 的生命周期
  ① 通过 BeanDefinition 获取 bean 的定义信息 
  ② 调用构造函数实例化 bean 
  ③ bean 的依赖注入 
  ④ 处理 Aware 接口 (BeanNameAware 、 BeanFactoryAware 、 ApplicationContextAware) 
  ⑤ Bean 的后置处理器 BeanPostProcessor- 前置 
  ⑥ 初始化方法 (InitializingBean 、 init-method) 
  ⑦ Bean 的后置处理器 BeanPostProcessor- 后置 
  ⑧ 销毁 bean
  


- 三级缓存 
    ABA
    A加载A，A放在三级缓存，创建B也放在三级缓存，B请求注入A，Spring容器从三级缓存中获取A的工厂对象，放在二级缓存，返回给B。
    B，完成后放在一级缓存。
    A在直接加载B

- 线上服务CPU彪高：
    top  ->   top  -Hp  ID     ->   printf "%x\n" PID (把线程 ID 转换为 16 进制)  -> jstack PID 打印出进程的所有线程信息  -> 最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。

- 三次握手
  客户端–发送带有 SYN 标志的数据包–一次握手–服务端
  服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
  客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

- RocketMQ的整体工作流程？
Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳
Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息
Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费


1、现场环境查看JVM运行情况
2、快速排序
3、JVM调优
4、现场遇到的问题排查
