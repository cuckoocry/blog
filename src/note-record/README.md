---
title: 学习笔记总结
category: 学习笔记

---


笔记的总览。将学习的知识点总结和归纳。



- 1、你们项目中有没有做过限流 ? 怎么做的 ?
    漏铜算法、令牌桶

## Redis

### 1、集群方式

- 主从复制：读写分离。（全量同步，增量同步）。保证不了高可用
- 哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知)
- 分片集群：解决海量数据，高并发。集群中有多个master，每个master保存不同数据。引入了哈希槽的概念


### 2、Redis 的集群方案 - 主从复制 （保证不了高可用）

建立集群、读写分离.

单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离.般都是一主多从，主节点负责写数据，从节点负责读数据.

主从同步数据的流程：

**全量同步**
1. 从节点请求主节点同步数据 (replication id、offset)
2. 主节点判断是否是第一次请求，是第一次就与从节点同步版本信息 (replication id和offset)
3. 主节点执行bgsave，生成rdb文件后，发送给从节点去执行
4. 在rdb生成执行期间，主节点会以命令的方式记录到缓冲区(一个日志文件)
5. 把生成之后的命令志文件发送给从节点进行同步

**增量同步**
1. 从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值
2. 主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步

哨兵模式:实现主从集群的自动故障恢复(监控、自动故障恢复、通知)



### 3、Redis作为缓存，MySQL的数据如何与Redis进行同步呢？

**双写一致性**：当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致。

- 读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间
- 写操作：**<font color=Red>延迟双删</font>**

延迟双删会造成脏数据，解决：

1. 采用分布式锁（读写锁）。【强一致性，性能差】
2. 异步通知。MQ、基于Canal的异步通知。【无代码嵌入】

保证数据的强一致我们当时采用的是redisson提供的读写锁来保证数据的同步.

**<font color=Red>强一致性的</font>**，采用Redisson提供的读写锁
① 共享锁: 读锁readLock，加锁之后，其他线程可以共享读操作
② 排他锁:独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作


### 4、为什么使用Redisson实现分布式锁而不是直接使用Redis的SETNX命令的原因？

使用Redisson实现分布式锁而不是直接使用Redis的`SETNX`命令的原因主要在于Redisson提供了更为丰富和高级的特性，这些特性使得分布式锁的实现更加健壮、安全且易于使用。以下是Redisson相对于直接使用`SETNX`的一些优势：


1. **锁的自动续期**：
    - Redisson支持锁的自动续期，这意味着即使持有锁的客户端在执行长时间任务时也不会因为锁超时而失去锁。这对于防止因任务未完成而导致的锁提前释放非常有用。
2. **可重入锁**：
    - Redisson的分布式锁是可重入的，这意味着同一个线程可以多次获取同一个锁而不会被阻塞。这是通过在Redis中存储线程信息和锁的递归次数来实现的。
3. **公平锁**：
    - Redisson支持公平锁，确保锁的获取是按照请求顺序来的，防止饥饿现象。
4. **锁的监控**：
    - Redisson提供了锁的监控功能，可以查看锁的状态，如锁的持有者、等待时间等。
5. **集群支持**：
    - Redisson支持Redis集群，能够在Redis集群环境中正确地实现分布式锁。
6. **异常处理**：
    - Redisson提供了更为完善的异常处理机制，如网络问题或Redis服务问题时的重试策略。
7. **简化代码**：
    - 使用Redisson可以大大简化分布式锁的代码实现，开发者不需要关心底层的Redis命令细节。
      相比之下，直接使用`SETNX`命令实现分布式锁会有以下限制：
- **锁续期**：需要手动实现锁续期逻辑，增加了复杂性。
- **可重入性**：`SETNX`本身不提供可重入锁的功能，需要额外的逻辑来支持。
- **公平性**：`SETNX`不支持公平锁，可能会导致某些线程长期无法获取锁。
- **集群兼容性**：在Redis集群环境中使用`SETNX`实现分布式锁可能会遇到问题，需要额外的逻辑来保证锁的正确性。
- **异常处理**：需要自己处理网络异常、Redis服务异常等情况。

  总的来说，虽然`SETNX`可以用于实现简单的分布式锁，但在复杂的生产环境中，Redisson提供了更为全面和可靠的解决方案。



### 5、持久化方式 RDB、AOF

1. 在Redis中提供了两种数据持久化的方式：1、RDB  2、AOF
2. RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。
3. AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据
4. RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，
    在AOF文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令。

### 6、Redis的数据过期策略

**Redis的数据过期策略**
1. **惰性删除**：访问key的时候判断是否过期，如果过期，则删除
2. **定期删除**：定期检查一定量的key是否过期(SLOW模式+ FAST模式
3. Redis的过期删除策略: 惰性删除 + 定期删除 两种策略进行配合使用


### 7、Redis是单线程的，但是为什么还那么快？

1. 完全基于内存的，C语言编写
2. 采用单线程，避免不必要的上下文切换可竞争条件
3. 使用多路I/O复用模型，非阻塞IO

I/O多路复用是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。
目前的I/O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。
在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件

> "Socket"指的是网络套接字，它是一种通信机制，允许在不同计算机上的进程之间进行网络通信。


## RocketMQ

### 1、用途
- 限流削峰、异步解耦、数据收集

### 2、系统架构

- NameServer：是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。
- Broker：

### 保证不丢失
  开启生产者确认机制、开启持久化功能、开启消费者确认机制为auto
### 重复消费问题
业务的唯一标识、（典型的幂等的问题）redis分布式锁、数据库的锁
### 消息堆积
提高消费者的消费能力，使用多线程、增加消费者、扩大队列容积


## 算法

http://localhost:8099/study-notes/heima-baodian/base/

### 快速排序

**算法描述**

1. 每一轮排序选择一个基准点（pivot）进行分区
    1. 让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区
    2. 当分区完成时，基准点元素的位置就是其最终位置
2. 在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （[divide-and-conquer](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm)）
3. 从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案


**快排特点**

1. 平均时间复杂度是 `O(nlog_2⁡n )`，最坏时间复杂度 `O(n^2)`

2. 数据量较大时，优势非常明显

3. 属于不稳定排序

### 插入排序

**算法描述**

1. 将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集

2. 重复以上步骤，直到整个数组有序


**与选择排序比较**

1. 二者平均时间复杂度都是 `O(n^2)`

2. 大部分情况下，插入都略优于选择

3. 有序集合插入的时间复杂度为 `O(n)`

4. 插入属于稳定排序算法，而选择属于不稳定排序

**提示**

> *插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序*




## 微服务

    注册中心、负载均衡、远程调用、服务熔断、网关

    注册中心：服务注册 、服务发现、服务状态监控
    Nacos与Eureka的区别：Nacos集群默认采用AP方式

负载均衡如何实现的: Ribbon 组件实现，, Feign的底层已经自动集成了Ribbon。

Ribbon负载均衡策略:轮询、权重、随机、区域敏感

服务雪崩：一个服务失败，导致整条链路的服务都失败的情形。
解决：第一个是服务降级，第二个是服务熔断，如果流量太大的话，可以考虑限流

分布式服务的接口幂等性如何设计：（保证重复调用的结果和单次调用的结果一致）。`token+redis`

### Spring bean 生命周期
1. 创建 Bean 的实例：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。
2. Bean 属性赋值/填充（依赖注入）：为 Bean 设置相关属性和依赖，例如@Autowired 等注解注入的对象、@Value 注入的值、setter方法或构造函数注入依赖和值、@Resource注入的各种资源。
3. Bean 初始化
4. 销毁 Bean

### Spring 怎么解决循环依赖的呢

单例 Bean 初始化完成，要经历三步： 实例化、属性赋值、初始化。

注入就发生在第二步，属性赋值，结合这个过程，Spring 通过三级缓存解决了循环依赖：

1. 一级缓存 : Map<String,Object> singletonObjects，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例
2. 二级缓存 : Map<String,Object> earlySingletonObjects，早期曝光对象，用于保存实例化完成的 bean 实例
3. 三级缓存 : Map<String,ObjectFactory<?>> singletonFactories，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。

当 A、B 两个类发生循环依赖时:
1. 创建 A 实例，实例化的时候把 A 对象⼯⼚放⼊三级缓存，表示 A 开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道
2. A 注⼊属性时，发现依赖 B，此时 B 还没有被创建出来，所以去实例化 B
3. B 从三级缓存通过对象工厂，A放在二级，自己放在一级
4. A拿到B，A把自己放在一级缓存

### 说说什么是 AOP

面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。

### 说说 JDK 动态代理和 CGLIB 代理

Spring 的 AOP 是通过动态代理来实现的，动态代理主要有两种方式 JDK 动态代理和 Cglib 动态代理，这两种动态代理的使用和原理有些不同。

JDK 动态代理

1. Interface：对于 JDK 动态代理，目标类需要实现一个 Interface。
2. InvocationHandler：InvocationHandler 是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。
3. Proxy：Proxy 利用 InvocationHandler 动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。 

CgLib 动态代理

1. 使用 JDK 创建代理有一大限制，它只能为接口创建代理实例，而 CgLib 动态代理就没有这个限制。
2. CgLib 动态代理是使用字节码处理框架 ASM，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。
3. CgLib 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，
   所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。


### Spring 管理事务的方式有几种？

- 编程式事务：在代码中硬编码(在分布式系统中推荐使用) : 通过 TransactionTemplate或者 TransactionManager 手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。
- 声明式事务：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用） : 实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）

### SpringBoot 自动配置原理了解吗？

SpringBoot 开启自动配置的注解是`@EnableAutoConfiguration` ，启动类上的注解`@SpringBootApplication`是一个复合注解，包含了`@EnableAutoConfiguration`：


- JVM 
  程序计数器：完成分支、循环、跳转、异常处理、线程恢复
  方法区：存储了每一个类的结构信息。包括：运行时常量池、字段

## JVM

### JVM监控及诊断工具-命令行篇
补充：如果某 Java 进程关闭了默认开启的UsePerfData参数（即使用参数-XX：-UsePerfData），那么jps命令（以及下面介绍的jstat）将无法探知该Java 进程。

- jps：查看正在运行的Java进程
- jstat：查看JVM统计信息。（用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据）
- jinfo：实时查看和修改JVM配置参数。
- jmap：导出内存映像文件&内存使用情况
- jhat：JDK自带堆分析工具。（hat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。）
  使用了jhat命令，就启动了一个http服务，端口是7000，即http://localhost:7000/，就可以在浏览器里分析。
- 




MySQL  锁

当然，MySQL中的锁是数据库管理系统用来保证数据一致性和完整性的重要机制。以下是MySQL中常见的几种锁类型：
1. **乐观锁（Optimistic Locking）**：这种锁不是MySQL内置的，而是通过应用程序来实现。乐观锁假设多个事务并发访问同一数据时，不会发生冲突，因此在大多数情况下不会对数据进行锁定。它通常通过版本号或时间戳来实现。
2. **悲观锁（Pessimistic Locking）**：与乐观锁相反，悲观锁假设多个事务并发访问同一数据时会发生冲突，因此在数据被访问时就进行锁定。
   以下是MySQL中具体的锁类型：
3. **表锁（Table Lock）**：
    - **共享锁（Shared Lock）**：多个事务可以同时获取同一张表的共享锁，用于读取操作。
    - **排他锁（Exclusive Lock）**：在事务对表进行写操作时使用，确保同一时间只有一个事务能对表进行写操作。
4. **行锁（Row Lock）**：
    - **记录锁（Record Lock）**：锁定特定的记录行。
    - **间隙锁（Gap Lock）**：锁定一个范围，但不包括记录本身，用于防止幻读。
    - **临键锁（Next-Key Lock）**：是记录锁和间隙锁的组合，锁定一个范围，并且包括记录本身。
5. **意向锁（Intention Lock）**：
    - **意向共享锁（Intention Shared Lock）**：表示事务打算在表中的某些行上设置共享锁。
    - **意向排他锁（Intention Exclusive Lock）**：表示事务打算在表中的某些行上设置排他锁。
6. **自增锁（AUTO-INC Lock）**：在插入数据时，为了保持自增字段的连续性，MySQL会对表施加自增锁。
   锁的粒度不同，对性能的影响也不同。表锁的开销较小，但并发性能较差；行锁的开销较大，但并发性能较好。在实际使用中，应根据具体场景选择合适的锁策略。

   
## MQ 

https://tobebetterjavaer.com/sidebar/sanfene/rocketmq.html#_7-roctetmq%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97

1、现场环境查看JVM运行情况
2、快速排序
3、JVM调优
4、现场遇到的问题排查

