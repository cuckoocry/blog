---
title: 区块链技术与应用
date: 2024-09-02
category:
  - web3
tag:
  - web3
  - 区块链
---

:::tip
北京大学公开课《区块链技术与应用》由肖臻老师讲授,主要讲解区块链的基本概念和实现原理，面向广大对区块链技术和应用感兴趣的同学。通过这门课的学习，能够掌握比特币、以太坊等区块链技术的设计思路并有效解决实际问题。

[课程来源：https://www.bilibili.com/video/BV1Vt411X7JF/?vd_source=7138dfc78c49f602f8d3ed8cfbf0513d](https://www.bilibili.com/video/BV1Vt411X7JF/?vd_source=7138dfc78c49f602f8d3ed8cfbf0513d)

[博客地址：ttp://zhenxiao.com/blockchain/](http://zhenxiao.com/blockchain/)

笔记内容主要是根据老师课程来，笔记内容也博采众长，加上自己的理解和总结。

:::

一些笔记：
1、 https://blog.nowcoder.net/n/30cbdb37108b4d93b3a5a93b8226ae31
2、 https://cn.leapwhale.com/zh/article/me0uzckk


## 课程大纲

**比特币**：

- 密码学基础
- 比特币的数据结构
- 共识协议和系统实现-挖矿算法和难度调整
- 比特币脚本
- 软分叉和硬分叉
- 匿名和隐私保护

**以太坊**：

- 概述:基于帐户的分布式账本-数据结构:状态树、交易树、收据树
- GHOST协议
- 挖矿:memory-hard mining puzzle-挖矿难度调整
- 权益证明
  - Casper the Friendly Finality Gadget(FFG)-智能合约

**总结与展望**

## 第二讲：比特币中的密码学原理

## 哈希

比特币中使用的：Cryptographic Hash Function（密码学哈希函数）

### **哈希算法**

哈希算法是一种**将任意长度的数据**映射为**固定长度的散列值**（也称为哈希值、摘要或指纹）的算法。哈希算法的主要特点：

1. 确定性（Determinism）：相同的输入总是产生相同的输出。
2. 快速计算（高效性）：对于给定的输入，哈希值可以迅速计算出来。
3. **抗碰撞性(Collision resistance)**：很难找到两个不同的输入，它们的哈希值相同（称为哈希碰撞）。
4. 不可逆性（单向性）：根据哈希值不能轻易逆推出原始输入。
5. 扩展性弱：微小的输入变化会导致哈希值的巨大差异（雪崩效应）。
6. **隐藏性（Hiding）**：隐藏性确保了即使知道哈希值，也不能推测出输入值的任何信息
7. **Puzzle-friendly**：在特定条件下找到一个满足要求的哈希值应当是计算上困难的。这个特性在工作量证明等机制中非常关键。

常见的哈希算法包括：

- MD5：产生128位的哈希值，曾经广泛用于数据完整性校验，但由于其抗碰撞性较弱，现在逐渐被弃用。
- SHA-1：产生160位的哈希值，也曾经广泛使用，但由于安全漏洞，已经不再推荐使用。
- **SHA-256**：属于SHA-2家族，产生256位的哈希值，广泛应用于安全性要求较高的场景，如区块链、数字签名等。

哈希算法在密码学、数据完整性校验、数字签名和其他计算机安全领域有着广泛的应用。



### 1、Collision resistance（抗碰撞性）

**Collision resistance（抗碰撞性）** 是哈希算法的重要属性之一。它指的是对于给定的哈希函数，很难找到两个不同的输入，它们的哈希值是相同的。

换句话说，抗碰撞性意味着虽然理论上可能存在两个不同的输入产生相同的哈希值（这种情况称为“碰撞”），但要找到这两个不同的输入是非常困难的。这种难度使得哈希算法在很多应用场景中非常有用，例如密码学、数据完整性校验和数字签名等。

为了更好地理解抗碰撞性，可以将其与其他两个相关的概念作比较：

1. **Preimage resistance（抗原像性）**：给定一个哈希值，很难找到一个输入，使得这个输入的哈希值等于给定的哈希值。

2. **Second preimage resistance（抗第二原像性）**：给定一个输入及其对应的哈希值，很难找到另一个不同的输入，使得这个不同的输入的哈希值与第一个输入的哈希值相同。

抗碰撞性专注于避免发现任何两个不同的输入产生相同的哈希值，从而保证哈希函数的唯一性和可靠性。如果一个哈希算法不具备抗碰撞性，那么它可能会容易受到攻击者的利用，使得算法的安全性受到威胁。

### 2、hiding（隐藏性）

在密码学中，**hiding（隐藏性）** 是指哈希函数的一个属性，通常与承诺方案（commitment schemes）相关。隐藏性确保了即使知道哈希值，也不能推测出输入值的任何信息。这种属性对于某些安全协议和密码学应用至关重要。

具体来说，隐藏性意味着：

1. **信息隐藏**：给定一个哈希值，应该无法推断出可能产生该哈希值的输入是什么。这保证了输入信息的保密性。

2. **不可预测性**：即使攻击者知道哈希值和部分信息，也不能轻易猜测出剩余的隐藏信息。例如，在某些承诺方案中，承诺者可以选择在后续阶段公开或隐藏某些信息，而这种隐藏信息在哈希值生成后是不可预测的。

#### 示例：承诺方案中的隐藏性

假设你想和别人玩一个游戏，你要选择一个值，但你不想在开始时公开这个值（防止对方作弊）。你可以将这个值通过一个哈希函数生成哈希值，然后公开这个哈希值。当游戏结束时，你再公开原始值，对方可以验证这个值的哈希值是否与之前公开的一致。这个过程依赖于哈希函数的隐藏性属性，因为在公开哈希值时，对方无法从中推断出你选择的原始值。

隐藏性在密码学应用中确保了数据的隐私性和不可预测性，是实现安全协议的一种关键机制。


### 3、Puzzle-friendly

**Puzzle-friendly** 是密码学中描述哈希函数特性的一种术语，通常用于讨论在某些加密协议或共识机制中的应用，尤其是在区块链中。具体来说，**puzzle-friendly** 的意思是，给定一个哈希函数，找到一个特定输出（通常具有特定特征，比如以某几个零开头的哈希值）应该是非常困难的，而唯一可行的方法就是通过反复尝试不同的输入来寻找这个特定的输出。

#### Puzzle-friendly 的特性
1. **计算成本高**：要找到满足条件的哈希值，通常需要进行大量的计算。换句话说，这个问题没有捷径，唯一的解决方法是进行暴力搜索，即反复尝试不同的输入，直到找到符合要求的输出。

2. **不可预测性**：由于哈希函数的不可逆性和抗碰撞性，在进行计算之前无法预见哪一个输入会生成所需的哈希值。这意味着每一次尝试都是独立的，无法利用前一次的结果来减少下一次的工作量。

3. **公平性**：由于每个人在解这个“谜题”时都必须做相似的工作量，所以在分布式系统或区块链中，这样的哈希函数可以帮助保证系统的公平性。

#### 示例：工作量证明（Proof of Work）
在区块链系统中，尤其是比特币这样的加密货币中，工作量证明机制依赖于“puzzle-friendly”哈希函数。矿工们必须找到一个区块头的哈希值，使得这个哈希值低于某个目标难度值。由于“puzzle-friendly”特性，矿工们唯一的选择就是反复尝试不同的随机数（称为“nonce”）来进行计算，直到找到一个符合条件的哈希值。

这个过程确保了添加新区块需要大量计算资源，从而维护了区块链网络的安全性和公平性。

### 4、Digital commitment（数字承诺）

**Digital commitment（数字承诺）** 是密码学中用于保证数据隐私性和完整性的一种协议或机制。它允许一个人（承诺者）在不透露特定信息内容的情况下“承诺”某个值，然后在未来的某个时间点“揭示”该值。数字承诺具有以下两个关键属性：

1. **隐藏性（Hiding）**：在承诺阶段，承诺者发布的承诺值不泄露所承诺的原始信息。这意味着在揭示之前，任何人都无法知道承诺的内容。

2. **绑定性（Binding）**：一旦承诺者发布了一个承诺值，他们就无法改变承诺的内容。也就是说，承诺者无法在揭示阶段选择不同的值，这确保了承诺的不可篡改性。

#### 数字承诺的工作过程

数字承诺通常分为两个阶段：

1. **承诺阶段（Commit Phase）**：承诺者选择一个秘密值，然后通过某种加密方式生成一个承诺值，将这个承诺值发布或发送给验证者。

2. **揭示阶段（Reveal Phase）**：在适当的时间点，承诺者揭示最初的秘密值，验证者可以使用之前的承诺值来验证揭示的值是否正确。

#### 示例

想象一下一个投标系统，其中投标者需要在特定时间之前提交投标金额。为了防止其他人知道他们的投标金额并提出更高的投标，投标者可以在提交金额之前生成一个数字承诺。当所有投标者都提交完毕后，他们再揭示各自的投标金额。通过对比揭示的金额与之前的承诺，系统可以验证投标者是否在投标时间内更改了他们的投标。

数字承诺在多种场景中被广泛应用，如电子投票、零知识证明、在线协议等，确保数据的隐私性和完整性。



## 签名

### 公钥（public  key）与私钥（private key）

它们是密码学中非对称加密的一部分，通常用于保护数据的安全性和隐私性。以下是关于公钥和私钥的详细说明：

#### 公钥（Public Key）
- **定义**：公钥是一个公开的密钥，任何人都可以获取和使用。
- **用途**：
  - **加密**：在加密通信中，公钥用于加密消息。因为公钥是公开的，任何人都可以使用它加密数据，但只有与之匹配的私钥可以解密这些数据。
  - **数字签名验证**：**公钥还用于验证数字签名的真实性**。当某人使用其私钥签名一条消息后，其他人可以使用该人的公钥来验证签名是否有效。
- **公开性**：正如名字所示，公钥是可以自由发布和共享的，不需要保密。

#### 私钥（Private Key）
- **定义**：私钥是一个秘密的密钥，必须妥善保管，不得泄露。
- **用途**：
  - **解密**：在加密通信中，私钥用于解密由公钥加密的数据。由于只有拥有私钥的人才能解密数据，因此私钥需要保持绝对的秘密性。
  - **数字签名**：**私钥用于生成数字签名**，以确保信息的真实性和不可否认性。签名后的消息可以通过公钥进行验证，确保它确实由私钥持有者发送。
- **保密性**：私钥必须严格保密，任何泄露都会导致安全风险，因为拥有私钥的人可以解密信息或者冒充私钥持有者进行数字签名。

#### 公钥和私钥的关系
公钥和私钥是一对密钥，它们是通过某种数学算法生成的，具有以下特性：
- 公钥和私钥可以互相配合使用。用公钥加密的信息只能用对应的私钥解密，反之亦然。
- 公钥和私钥之间的数学关系使得公钥能够验证由私钥生成的数字签名。

#### 示例：非对称加密和数字签名
1. **非对称加密**：Alice想给Bob发送一条保密消息。她使用Bob的公钥加密这条消息，然后发送给Bob。由于只有Bob拥有与公钥对应的私钥，所以只有Bob可以解密并阅读这条消息。

2. **数字签名**：Bob想证明他发送的一条消息的真实性和完整性。他用自己的**私钥对消息进行签名**，然后将消息和签名一起发送给Alice。Alice可以用Bob的**公钥验证签名**，以确认这条消息确实来自Bob，并且在传输过程中没有被篡改。

公钥和私钥的使用是现代数字安全的重要组成部分，广泛应用于SSL/TLS协议、电子邮件加密、区块链技术、数字证书等领域。


## 总结

- 哈希的特性以及理解。

- 签名的概念以及原理。

所以BTC包含的密码学原理就是哈希函数以及签名。哈希函数的一些特性以及签名的方式保证了BTC的安全性。

## 第三讲：比特币中的数据结构

### Hash Pointers（哈希指针）

**Hash Pointers（哈希指针）**。哈希指针是一种结合了指针和哈希值的数据结构，广泛应用于区块链、密码学和数据完整性验证等领域。

![img_1.png](images/img_1.png)

#### Hash Pointer 的概念
- **指针部分**：指向某个数据块或数据对象的存储位置，类似于传统的指针。
- **哈希值部分**：存储指向的数据块的哈希值。

这种组合具有两个重要的特性：
1. **数据定位**：指针部分可以定位到实际的数据位置（通常是内存地址或存储单元）。
2. **数据完整性验证**：哈希值部分用于验证指针所指向的数据是否被篡改。通过重新计算指向数据的哈希值并与存储的哈希值进行对比，可以检测出任何数据的变化。

#### Hash Pointer 的应用

##### 1. 区块链
在区块链中，Hash Pointer 是区块链数据结构的基础。例如，**比特币区块链中，每个区块包含一个指向前一个区块的哈希指针**。这意味着每个区块不仅包含对前一个区块的引用，还包含前一个区块的哈希值，从而确保了区块链的不可篡改性。如果某人试图篡改历史区块中的数据，他们必须修改所有后续区块的哈希值，这几乎是不可能的。

##### 2. Merkle 树
Merkle 树是一种基于哈希指针的数据结构，常用于验证数据的完整性。Merkle 树的叶节点是数据的哈希值，而每个非叶节点是其子节点哈希值的组合哈希。根节点的哈希值称为 Merkle 根，通过这个哈希值可以验证整个树的完整性。Merkle 树广泛应用于区块链、分布式系统和版本控制系统中。

##### 3. 数据版本控制
在版本控制系统中，Hash Pointer 可以用于跟踪文件或数据对象的历史版本。每个版本的对象通过哈希指针指向其前一个版本，从而构建一个链条，这样可以有效地管理和验证不同版本之间的差异和完整性。

#### Hash Pointer 的优点
- **安全性**：通过哈希值的验证，可以确保数据的完整性和防篡改性。
- **高效性**：在数据存储和版本控制中，Hash Pointer 提供了一种高效的数据引用和验证机制。
- **不可篡改性**：一旦数据被记录下来并形成哈希指针链条，任何篡改都会破坏链条的完整性，从而被检测出来。

#### 总结
Hash Pointer 通过将数据指针和哈希值结合，提供了一种强大的数据结构，用于数据完整性验证和防篡改。这种结构在区块链、Merkle 树和版本控制系统中有着广泛的应用。

### Tamper-Evident Log

哈希指针的一个主要优点是它提供了一种不可篡改的日志（tamper-evident log）。

- **完整性验证**：由于每个区块都包含前一个区块的哈希值，任何对某个区块的篡改都会改变该区块的哈希值，从而导致其后所有区块的哈希值发生变化。这样，篡改行为可以很容易地被检测到。
- **防篡改链**：因为每个区块都依赖前一个区块的哈希值，如果某人试图修改一个区块，不仅需要修改该区块，还需要修改其后的所有区块，这几乎是不可能完成的任务。


### Merkle Tree

Merkle Tree （Merkle 树）：是一种用于验证数据完整性的树形结构，广泛应用于分布式系统、区块链和文件系统中。它通过哈希函数确保数据的不可篡改性。

Binary Tree （二叉树）：是一种每个节点最多有两个子节点的数据结构，广泛用于算法设计和计算机科学的各类问题中。二叉树主要用于高效的查找、插入、删除操作。

**Merkle Tree**

![img.png](images/img.png)

在比特币系统中，Merkle Tree（默克尔树）是用于组织和验证交易数据的一种重要结构。它的基本单元是底层的数据块，这些数据块实际上是一笔笔交易。

每个block有一个默克尔树，树中每个叶子节点是一个交易的hash值（比特币使用双重SHA256哈希）。叶子节点的数量一定是偶数，然后并非每个block都恰好有偶数个交易。当block有奇数个交易时，最后一个交易会被复制一次（复制仅仅发生在默克尔树中而不是block中！）。

默克尔树自下而上的进行组织，叶子节点成对分组后将两个hash值组合后生成新的hash值，形成上层的树节点，重复整个过程直到只有一个树节点为止，也就是所说的根节点。**根节点的hash值是整个交易集的唯一标识，保存在block头信息中，用于PoW过程。根节点（Root Hash）代表了整个树的哈希值，只要记住这个根哈希值，就可以检测到整个树上的任意修改。**

![img_2.png](images/img_2.png)

### Merkle Proof

Merkle Tree 的一个重要好处是可以进行 Merkle Proof。Merkle Proof 是一种用于证明某个数据块（交易）存在于一棵给定的 Merkle Tree 中的方法。

#### 全节点与轻节点

- 全节点：保存了整个区块链的所有数据，包括所有的交易和块。
- 轻节点：仅保存区块头（Block Header），而不保存所有交易数据。


#### 轻节点的交易验证

假设你在手机上运行的是一个轻节点，如果我给你做了一笔转账，你需要验证这笔交易已经存在于区块链中，这时就需要用到 Merkle Proof。

从下往上验证。

![img_3.png](images/img_3.png)

#### 验证过程

- 接收路径（Merkle Proof）：轻节点从全节点或其他来源接收一个路径，这个路径包括从目标交易到根哈希的所有哈希值。
- 验证路径：轻节点使用这个路径验证该分支路径的哈希值与最终的区块头（Block Header）是否一致。如果一致，就证明该交易存在于区块链中。这个过程证明的是`Proof of Membership`，其复杂度是 `O(log⁡n)`。

#### Proof of Non-Membership

如何证明某个交易不在区块链中（Proof of Non-Membership）, 当前没有比较高效的方法，只能一个个查验，其复杂度是 O(n)。

#### Sorted Merkle Tree

如果交易数据是有序的，根据哈希值排序，这种结构被称为 `Sorted Merkle Tree`。这种结构允许快速查找某个交易是否存在。但比特币并没有用这种结构，它不需要这个功能，排序也是需要额外代价的。

## 第四讲：比特币的共识协议

### BTC协议

比特币协议包括铸币、交易过程和防止双花攻击等机制。

![img_4.png](images/img_4.png)


### 铸币和交易过程

每笔交易包含输入和输出部分：

- 输入部分：说明币的来源（即之前的交易）和转账人的公钥。转账人的公钥需要与币来源的公钥相匹配，确保合法性。
- 输出部分：指明收款人的公钥。这次交易需要有发送人的签名，确保交易是由合法的持币人发起的。

哈希指针用于指向之前的某个交易，证明这部分钱的来源，防止凭空捏造币。这个机制也防范了双花攻击。

### Double Spending Attack 双重支付攻击（双花攻击）

是指在网络上的数字货币系统中，攻击者试图在同一时间内将同一笔货币资产花费两次。这种攻击如果成功，会导致同一笔货币被两个不同的接收者接受，从而造成货币的重复使用。

双花攻击是指同一笔比特币被花费两次的情况。比特币通过以下机制防止双花攻击：

- 区块链共识：每笔交易都需要被矿工打包进区块，并通过共识机制确认。
- 交易验证：当一个新的区块被广播时，网络中的所有节点都会验证其中的每笔交易是否合法，检查是否有双花行为。
- 最长链规则：比特币网络会选择最长的合法链。如果双花交易发生在不同的区块中，只有包含在最长链中的交易会被认可。

#### 双花攻击检测示例

假设Alice试图将同一笔比特币分别转给Bob和Charlie：

- 广播两笔交易：Alice向Bob和Charlie分别发起两笔相同输入的交易，并几乎同时广播到网络中。
- 矿工打包：矿工收到这两笔交易，并分别打包进不同的区块中，形成两个分叉。
- 分叉传播：网络中的节点会接收到这两个分叉的区块链，暂时分裂为两个分支。
- 最长链选择：随着时间推移，矿工继续挖矿并生成新区块。当某个分支被延长，形成新的最长链时，另一个分支的区块将被丢弃，成为孤块。
- 交易确认：最终，只有包含在最长链中的交易会被确认和接受。此时，Alice的双花攻击会失败，因为只有一笔交易会被区块链网络接受，另一笔交易会被回滚。

比特币挖矿每十分钟一个区块，其实也是为了防止分叉攻击，不然时间太短，叉太多，就容易被攻击


### 区块结构

每个区块由区块头（Block Header）和区块体（Block Body）组成。

区块头包含以下字段：

- **版本号（version）**：表明区块的版本。
- **前一个区块的哈希值（previous block hash）**：指向前一个区块，确保链条的连续性。
- **Merkle根（Merkle root）**：当前区块中所有交易的哈希值经过Merkle树计算得到的根哈希。
- **时间戳（timestamp）**：记录区块创建的时间。
- **难度目标（nbits）**：当前区块的挖矿难度。
- **随机数（nonce）**：用于挖矿的计数器。

**区块体**包含一个交易列表（transaction list），记录所有包含在该区块中的交易。

### 区块验证

其他节点收到新区块后，会进行一系列验证，以确保区块的合法性：

- 哈希值验证：检查区块头的哈希值是否小于难度目标。
- 前一个区块的哈希：验证前一个区块的哈希值是否与本地链的最后一个区块匹配。
- **交易验证：** 验证区块中的每笔交易是否合法，包括：
  - 签名有效性：检查交易的签名是否由合法的私钥生成。
  - 双花检测：确保每笔输入没有在之前的区块中被花费。
- Merkle根验证：检查交易列表的Merkle根是否与区块头中的Merkle根一致。
  如果区块通过所有验证，它将被添加到本地区块链中，否则将被拒绝。


### 分布式共识

::: info
可否各个节点独立完成区块链构建？
很明显不行，各个节点独立打包交易，形成区块链，必然无法避免区块链内容不一致。从分布式系统角度来说，账本内容需要取得分布式共识，从而保证区块链内容在不同节点上的一致性。
:::

- 根据FLP不可能结论，在一个异步系统中，网络时延无上限，即使只有一个成员是有问题的，也不可能达成共识。
- 根据CAP Theorem（Consistency一致性、Availability可靠性、Partition tolerance容错性），任何一个分布式系统中，最多只能满足其中两个性质。
- 分布式共识中协议Paxos 可以保证Consistency（若达成共识必然一致），但在某些情况下，可能会一直无法达成共识。

::: info
>女巫攻击（Sybil Attack）:在分布式系统中是一种常见的攻击方式,指的是一个恶意节点通过控制多个身份来影响网络中的共识过程。


在比特币的分布式共识机制——工作量证明（Proof of Work，PoW）中，女巫攻击的具体影响如下：
- 身份伪造：攻击者创建大量虚假身份（节点），在网络中伪装成不同的参与者。
- 影响共识：通过控制大量节点，攻击者可以试图影响比特币网络中的共识决策过程，例如在比特币的分叉选择中，攻击者可以使网络认为其伪造的链是合法的，从而尝试推翻真实的区块链。
- 网络分割：攻击者可以利用这些虚假身份对网络进行分割，使得网络中的部分节点无法接收到其他节点的信息，从而破坏网络的去中心化特性。
:::

谈到共识，我们可能会想到投票，但是任何基于投票的共识协议都有一个投票权的问题，可能会存在女巫攻击，在比特币系统中简单的采用投票来确定共识是不行的。比特币网络通过 **工作量证明（Proof of Work, PoW）** 来实现分布式共识，确保所有节点就区块链的状态达成一致。其核心思想是通过消耗计算资源来防止女巫攻击和其他恶意行为。具体过程如下：

- 挖矿过程：矿工竞争性地进行大量的哈希运算，试图找到一个满足特定条件的哈希值（即目标值以下的哈希）。
- 哈希值计算：矿工对区块头进行哈希运算，区块头包括前一个区块的哈希值、当前区块中的交易Merkle根、时间戳、难度目标（nbits）和随机数（nonce）。
- 目标值：难度目标（nbits）决定了哈希值必须小于的目标值。随着网络计算能力的变化，难度调整每2016个区块（大约两周）进行一次。确保新区块生成时间约为每10分钟一次。如果区块生成过快，难度会增加；如果生成过慢，难度会降低。



#### 比特币共识协议

::: info 背景
背景：假设系统中存在部分节点有恶意，但存在比例较小。大多数节点为“好”的节点，在这种情况下进行共识协议设置。
- 想法1：直接投票
某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半数，加入区块链。

- 存在的问题1——恶意节点不断打包不合法区块，导致一直无法达成共识，时间全花费在投票上。
- 存在的问题2——无强迫投票手段，某些节点不投票（行政不作为）。
- 存在的问题3——网络延迟事先未知，投票需要等多久？效率上会产生问题。

更大的一个问题 —— membership(资格)。
如果是联盟链（hyperledger），对加入成员有要求，可以基于投票。
但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候,比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得支配地位（女巫攻击`Sybil Attack`）。所以，这种简单的投票方案也是不可行的。
:::

比特币系统中采用了很巧妙的方案解决这个问题。虽然仍然是投票，但并非简单的根据账户数目，而是依据计算力进行投票。

在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种`nonce`值，这就是挖矿。
`[H(block header)<=target]` 当某个节点找到符合要求的`nonce`，便获得了记账权，从而可以将区块发布到系统中。
其他节点受到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。


> 区块合法，但不一定就能接收。 得满足区块在最长合法（longest valid chain）链上。

### 共识协议和分叉处理

#### 最长链规则

比特币网络采用最长链规则来决定哪条链是合法的。即所有节点选择包含最多工作量（即最长）的合法链。这样确保了网络的一致性和**防止分叉攻击（forking attack）**。

> 如果是等长，怎么办？ 那就看谁先找到下一个区块成为最长区块链了。

#### 分叉处理

如果两个矿工几乎同时找到有效区块，会出现链的分叉。此时：

- 暂时分叉：网络中的节点会临时分裂为两个分支，分别接收其中一个区块。
- 最终选择：当一个分支被后续区块延长并超过另一个分支时，较短分支上的区块将被丢弃，成为孤块（orphan block）。
- 回滚交易：孤块上的交易会被回滚到未确认状态，并可能被包含在后续的区块中。

![img_5.png](images/img_5.png)


> 那么为什么都要竞争记账权呢？ 会消耗资源，算力和电力成本有什么好处呢？ 我们是期望凡事合法的交易都应该被写到区块链里的。 所以有比特币激励机制`block reward`。

### 比特币激励机制

> 为什么系统中节点要竞争记账权？需要提供算力和电力成本，节点为什么要去做？

比特币系统设计之初便考虑到了这个问题，那就是引入激励机制`block reward`。
比特币通过设置出块奖励来解决该问题，一个获得合法区块的节点，可以在区块中加入一个特殊交易（铸币交易）。事实上，这种方式也是唯一一个产生新比特币的途径。

矿工在成功找到满足条件的哈希值后，获得记账权并将新区块广播到全网。新区块包含一个特殊的交易（**铸币交易 coinbase transaction**），用于奖励矿工：

- 出块奖励：最初的出块奖励为`50 BTC`，每经过210,000个区块（约4年）奖励减半。当前（2024年）奖励为`6.25 BTC`。
- 交易费用：除了出块奖励，矿工还可以获得包含在区块内交易的交易费用。这些费用由交易发起人支付，作为矿工打包交易的激励。


## 第五讲：比特币系统的实现

区块链是一个去中心化的账本，比特币采用了 **基于交易的账本模式 (`transaction-based ledger`)**。
然而，系统中并无显示记录账户包含比特币数，实际上其需要通过交易记录进行推算。在比特币系统中，全节点需要维护一个名为**`UTXO`(`Unspent Transaction Output`尚未被花掉的交易输出)的数据结构**。