---
title: 面试指南-Java集合框架
category: 面试指南
order: 2
---


::: tip

Be a better version of yourself

:::


## List

### 1、ArrayList 和 Array（数组）的区别？

`ArrayList`内部基于动态数组实现，比` Array`（静态数组） 使用起来更加灵活 ：
- `ArrayList`会根据实际存储的元素动态地扩容或缩容，而 `Array` 被创建之后就不能改变它的长度了。
- `ArrayList` 允许你使用泛型来确保类型安全，`Array` 则不可以。
- `ArrayList` 中只能存储**对象**。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。`Array` 可以直接存储基本类型数据，也可以存储对象。
- `ArrayList` 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 `add()`、`remove()`等。`Array` 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。
- `ArrayList`创建时不需要指定大小，而`Array`创建时必须指定大小。

### 2、 `ArrayList`扩容规则

**扩容规则**

1. `ArrayList()`,以无参数构造方法创建`ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。

2. `ArrayList(int initialCapacity)` 会使用指定容量的数组

3. `public ArrayList(Collection<? extends E> c) `会使用 c 的大小作为数组容量

4. add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍

5. addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)

> 复制旧数组：扩容后，ArrayList 会将原来的数组内容复制到新数组中。

> int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！

> ">>"（移位运算符）：>>1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。

### 3、 `ArrayList` 对比 `LinkedList`的区别

**LinkedList**

1. 基于双向链表，无需连续内存
2. 随机访问慢（要沿着链表遍历）
3. 头尾插入删除性能高
4. 占用内存多

**ArrayList**

1. 基于数组，需要连续内存
2. 随机访问快（指根据下标访问）
3. 尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低
4. 可以利用 cpu 缓存，局部性原理

## Map

### 1、`HashMap`的基本数据结构

* 1.7 数组 + 链表
* 1.8 数组 + （链表 | 红黑树）

拿到key,拿到key的hashCode，二次hsah,与数组容量减一去按位与（ `(n - 1) & hash`），计算出key的索引位置，也就是桶下标。

### 2、`HashMap`的树化

**树化意义**：

* 红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略
    * hash 表的查找，更新的时间复杂度是 `O(1)`，而红黑树的查找，更新的时间复杂度是 `O(log_2⁡n )`，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表
    * hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006(一亿分之6)，树化阈值选择 8 就是为了让树化几率足够小

**树化规则**：

当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 >=64，才会进行树化。 

> 注：链表长度可能超过8的。

**树退化规则**：

* 情况1：在扩容时如果拆分树时，树元素个数 <= 6 则会退化链表
* 情况2：remove 树节点时，（移除之前判断）若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表


### 3、`HashMap`索引计算

#### 索引计算方法

`HashMap` 通过 `key` 的 `hashcode` 经过扰动函数(`hash()` 方法)处理过后得到 `hash` 值，
然后通过` (n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），

> 二次 hash() 是为了综合高位数据，让哈希分布更为均匀.

>一句话总结，key的hashcode二次哈希得到hash值，hash值与数组长度减一位与运算。`&`

#### 数组容量为何是 2 的 n 次幂

1. 计算索引时效率更高：位运算(&)比取余运算(%)更高效。当长度为 2 的幂次方时，`hash % lengt`h 等价于 `hash & (length - 1)`。
2. **扩容时重新计算索引效率更高**： `hash & oldCap（旧容量） == 0 `的元素留在原来位置 ，否则`新位置 = 旧位置 + oldCap`
3. 可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。

**注意**

* 二次 hash 是为了配合 **容量是 2 的 n 次幂** 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash
* **容量是 2 的 n 次幂** 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable


#### put 与扩容

put 流程:

1. HashMap 是懒惰创建数组的，首次使用才创建数组
2. 计算索引（桶下标）。（拿到key的hashCode，二次hsah,与数组容量减一去按位与，计算出key的索引位置，也就是桶下标）
3. 如果桶下标还没人占用，创建 Node 占位返回。键值对插入该位置
4. 如果桶下标已经有人占用
  1. 已经是 TreeNode 走红黑树的添加或更新逻辑
  2. 是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑
5. 返回前检查容量是否超过阈值，一旦超过进行扩容

**1.7 与 1.8 的区别**

1. 链表插入节点时，1.7 是头插法，1.8 是尾插法

2. 1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容

3. 1.8 在扩容计算 Node 索引时，会优化


`HashMap` 的扩容机制：

1. 初始容量：HashMap 的默认初始容量是 16，加载因子（load factor）为 0.75。
2. 触发扩容：当 HashMap 中的元素数量超过`容量 * 加载因子` 时，会触发扩容。例如，默认情况下，当 HashMap 中的元素数量超过 12（16 * 0.75）时，就会进行扩容。
3. 扩容过程：
- 扩容时，HashMap 会将容量翻倍，并重新计算所有已有元素的索引位置，将它们重新分配到新的数组中。
- 在重新分配时，由于数组长度的变化，元素的位置可能会改变，因此需要重新计算哈希值和索引位置，这个过程称为 `rehashing`。

**扩容（加载）因子为何默认是 0.75f**

1. 在空间占用与查询时间之间取得较好的权衡
2. 大于这个值，空间节省了，但链表就会比较长影响性能
3. 小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多
